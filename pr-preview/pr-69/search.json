[{"path":[]},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"question","dir":"Articles","previous_headings":"Motivation","what":"Question","title":"Benchmarking dplyr vs RSQL","text":"Y--t-il une diff√©rence de performance sur le portail entre manipuler les donn√©es avec la syntaxe dplyr ou en injectant du SQL directement dans une requ√™te de DBI::dbExecute ?","code":""},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"description-du-benchmark","dir":"Articles","previous_headings":"Motivation","what":"Description du benchmark","title":"Benchmarking dplyr vs RSQL","text":"La p√©riode retenue est 2020-2023. Le benchmark √©tudie le temps pris par les deux solutions de fa√ßon incr√©mentale : 1 mois, 1 ans, 2 ans, 3 ans. L‚Äôextraction est faite en bouclant par mois sur la date de flux.","code":""},{"path":[]},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"comparaison-des-performances-entre-dplyr-et-rsql","dir":"Articles","previous_headings":"Code de benchmark","what":"Comparaison des performances entre dplyr et RSQL","title":"Benchmarking dplyr vs RSQL","text":"","code":"library(sndsTools)  # Param√®tres d'extraction atc_vitamine_d_7 <- c(\"M05BB03\", \"M05BB04\", \"A11CC05\", \"A11CC01\", \"A12CD51\")  atc_vitamine_d_5 <- c(\"A12AX\", \"A11JA\", \"A11BA\")  cip_vitamine_d_b <- c(3400935657190, 3400936584969, 3400936923751, 3400934880254)  # Colonnes suppl√©mentaires pour la fonction `extract_drug_dispenses`. # Ces colonnes sont extraites par d√©faut dans la fonction `sql_extract_drug_dispenses`. sup_columns <- c(   \"BEN_CMU_TOP\",   \"BEN_AMA_COD\",   \"BEN_SEX_COD\",   \"BEN_RES_DPT\",   \"FLX_DIS_DTD\",   \"PRS_ACT_QTE\",   \"BSE_REM_MNT\",   \"BSE_PRS_NAT\",   \"ETE_IND_TAA\",   \"ETB_EXE_FIN\",   \"ETE_MCO_DDP\",   \"PHA_GRD_CND\",   \"PHA_PRS_IDE\",   \"PHA_DEC_TOP\",   \"PHA_DEC_QSU\" )  conn <- connect_oracle()  start_dates <- rep(as.Date(\"2020-01-01\"), 3) end_dates <- c(   # as.Date(\"2020-02-01\"),   as.Date(\"2021-01-01\"),   as.Date(\"2022-01-01\"),   as.Date(\"2023-01-01\") )  path2_tmp <- file.path(\"../inst/extdata\")    for (i in seq_along(start_dates)) {   start_date <- start_dates[i]   end_date <- end_dates[i]   message(\"Extraction pour la p√©riode : \", start_date, \" - \", end_date)    # benchmark de dplyr   formatted_study_dates <- glue::glue('{format(start_date, \"%Y%m%d\")}_{format(end_date, \"%Y%m%d\")}')   dplyr_table_name <- glue::glue(\"dplyr_{formatted_study_dates}\")   time_0_dplyr <- Sys.time()   extract_drug_dispenses(     start_date = start_date,     end_date = end_date,     atc_cod_starts_with_filter = atc_vitamine_d_7,     cip13_cod_filter = cip_vitamine_d_b,     output_table_name = dplyr_table_name,     sup_columns = sup_columns,     conn = conn   )   time_taken_dplyr <- as.numeric(lubridate::as.duration(Sys.time() - time_0_dplyr), \"seconds\")   n_rows_dplyr <- DBI::dbGetQuery(conn, glue::glue(\"select count(*) from {dplyr_table_name}\"))   # tmp_table_dplyr <- DBI::dbGetQuery(conn, glue::glue(\"select * from {dplyr_table_name}\"))   # tmp_table_path <- file.path(path2_tmp, paste0(dplyr_table_name, \".parquet\"))   # arrow::write_parquet(tmp_table_dplyr, tmp_table_path)    dbExecute(conn, glue::glue(\"DROP TABLE {dplyr_table_name}\"))    # benchmark de RSQL   sql_table_name <- glue::glue(\"sql_{formatted_study_dates}\")   time_0_sql <- Sys.time()   sql_extract_drug_dispenses(     start_date = start_date,     end_date = end_date,     atc_cod_starts_with_filter = atc_vitamine_d_7,     cip13_cod_filter = cip_vitamine_d_b,     output_table_name = sql_table_name,     conn = conn   )   time_taken_sql <- as.numeric(lubridate::as.duration(Sys.time() - time_0_sql), \"seconds\")   n_rows_sql <- DBI::dbGetQuery(conn, glue::glue(\"select count(*) from {sql_table_name}\"))   # tmp_table_sql <- DBI::dbGetQuery(conn, glue::glue(\"select * from {sql_table_name}\"))   # tmp_table_path <- file.path(path2_tmp, paste0(sql_table_name, \".parquet\"))   # arrow::write_parquet(tmp_table_sql, tmp_table_path)    # enregistrement des r√©sultats   tmp_timing_results <- data.frame(     start_date = as.character(start_date),     end_date = as.character(end_date),     time_taken_dplyr = time_taken_dplyr,     time_taken_sql = time_taken_sql,     n_rows_dplyr = n_rows_dplyr,     n_rows_sql = n_rows_sql   )   dbExecute(conn, glue::glue(\"DROP TABLE {sql_table_name}\"))    write.table(     tmp_timing_results,     file.path(\"..\", \"inst\", \"extdata\", \"timing_results.csv\"),     append = i > 1,     row.names = FALSE,     col.names = i == 1,     sep = \",\"   ) }"},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"evaluation-de-la-vitesse-dextraction-dplyr-en-fonction-du-nombre-de-lignes-et-de-colonnes-extraites","dir":"Articles","previous_headings":"Code de benchmark","what":"Evaluation de la vitesse d‚Äôextraction dplyr en fonction du nombre de lignes et de colonnes extraites","title":"Benchmarking dplyr vs RSQL","text":"Le code suivant effectue diff√©rent test pour √©valuer la sensibilit√© de la vitesse d‚Äôextraction de dplyr en fonction du nombre de lignes et de colonnes extraites.","code":"library(sndsTools)  # Param√®tres d'extraction atc_vitamine_d_7 <- c(\"M05BB03\", \"M05BB04\", \"A11CC05\", \"A11CC01\", \"A12CD51\") atc_vitamine_d_5 <- c(\"A12AX\", \"A11JA\", \"A11BA\") cip_vitamine_d_b <- c(3400935657190, 3400936584969, 3400936923751, 3400934880254)  # Colonnes suppl√©mentaires pour la fonction `extract_drug_dispenses`. # Ces colonnes sont extraites par d√©faut dans la fonction `sql_extract_drug_dispenses`. columns_to_extract <- c(   \"BEN_CMU_TOP\",   \"BEN_AMA_COD\",   \"BEN_SEX_COD\",   \"BEN_RES_DPT\",   \"FLX_DIS_DTD\",   \"PRS_ACT_QTE\",   \"BSE_REM_MNT\",   \"BSE_PRS_NAT\",   \"ETE_IND_TAA\",   \"ETB_EXE_FIN\",   \"ETE_MCO_DDP\",   \"PHA_GRD_CND\",   \"PHA_PRS_IDE\",   \"PHA_DEC_TOP\",   \"PHA_DEC_QSU\" )  conn <- connect_oracle()  start_dates <- rep(as.Date(\"2020-01-01\"), 2) end_dates <- c(   as.Date(\"2020-02-01\"),   as.Date(\"2021-01-01\") )  columns_to_extract_list_length <- c(5, 10, 15)  for (i in seq_along(start_dates)) {   for (j in seq_along(columns_to_extract_list_length)) {     start_date <- start_dates[i]     end_date <- end_dates[i]     sup_columns <- columns_to_extract[1:columns_to_extract_list_length[j]]     message(\"Extraction pour la p√©riode : \", start_date, \" - \", end_date, \" avec \", columns_to_extract_list_length[j], \" colonnes suppl√©mentaires\")      # benchmark de dplyr     formatted_study_dates <- glue::glue(       '{format(start_date, \"%Y%m%d\")}_{format(end_date, \"%Y%m%d\")}'     )     dplyr_table_name <- glue::glue(\"dplyr_{formatted_study_dates}\")     time_0_dplyr <- Sys.time()     extract_drug_dispenses(       start_date = start_date,       end_date = end_date,       atc_cod_starts_with_filter = atc_vitamine_d_7,       cip13_cod_filter = cip_vitamine_d_b,       output_table_name = dplyr_table_name,       sup_columns = sup_columns,       conn = conn     )     time_taken_dplyr <- as.numeric(lubridate::as.duration(Sys.time() - time_0_dplyr), \"seconds\")     df_dplyr <- DBI::dbGetQuery(conn, glue::glue(\"select * from {dplyr_table_name}\"))     n_rows_dplyr <- nrow(df_dplyr)     dbExecute(conn, glue::glue(\"DROP TABLE {dplyr_table_name}\"))      # enregistrement des r√©sultats     tmp_timing_results <- data.frame(       start_date = as.character(start_date),       end_date = as.character(end_date),       time_taken_dplyr = time_taken_dplyr,       n_rows_dplyr = n_rows_dplyr,       n_cols_dplyr = 6 + length(sup_columns)     )      top_create_file <- (i == 1) && (j == 1)     write.table(       tmp_timing_results,       file.path(\"..\", \"inst\", \"extdata\", \"timing_results_cols.csv\"),       append = !top_create_file,       row.names = FALSE,       col.names = top_create_file,       sep = \",\"     )   } }"},{"path":[]},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"benchmark-dplyrrsql","dir":"Articles","previous_headings":"R√©sultats","what":"benchmark dplyr/RSQL","title":"Benchmarking dplyr vs RSQL","text":"","code":"library(sndsTools) path2pkg_data <- system.file(\"extdata\", package = \"sndsTools\") # path2pkg_data <- \"../inst/extdata\" timing_results <- read.csv(file.path(path2pkg_data, \"benchmark_rsql_dplyr.csv\")) |>   dplyr::mutate(     time_taken_dplyr_minutes = time_taken_dplyr / 60,     time_taken_sql_minutes = time_taken_sql / 60,     query_period_days = as.numeric(as.Date(end_date) - as.Date(start_date)),     query_period_months = as.integer(query_period_days / 30),     speed_dplyr_nrows_sec = n_rows_dplyr / time_taken_dplyr,     speed_sql_nrows_sec = n_rows_sql / time_taken_sql   ) ## Warning in read.table(file = file, header = header, sep = sep, quote = quote, : ## incomplete final line found by readTableHeader on ## '/home/runner/work/_temp/Library/sndsTools/extdata/benchmark_rsql_dplyr.csv' timing_results ##   start_date   end_date time_taken_dplyr time_taken_sql n_rows_dplyr n_rows_sql ## 1 2020-01-01 2020-02-01         235.2178       226.4485      4344991    4344991 ## 2 2020-01-01 2021-01-01         763.0326       794.2415     48131314   48131314 ## 3 2020-01-01 2022-01-01        1613.4070      1613.7409    108979756  108979756 ## 4 2020-01-01 2023-01-01        2558.6327      2260.9095    171408536  171408536 ##   time_taken_dplyr_minutes time_taken_sql_minutes query_period_days ## 1                 3.920297               3.774142                31 ## 2                12.717210              13.237359               366 ## 3                26.890116              26.895682               731 ## 4                42.643879              37.681825              1096 ##   query_period_months speed_dplyr_nrows_sec speed_sql_nrows_sec ## 1                   1              18472.20            19187.54 ## 2                  12              63078.97            60600.35 ## 3                  24              67546.35            67532.37 ## 4                  36              66992.24            75813.98"},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"dur√©e-des-extractions","dir":"Articles","previous_headings":"R√©sultats > benchmark dplyr/RSQL","what":"Dur√©e des extractions","title":"Benchmarking dplyr vs RSQL","text":"","code":"# plot time results library(ggplot2)  label_size <- 20  x_breaks <- unique(timing_results$query_period_months) timing_results |>   dplyr::rename(     dplyr = time_taken_dplyr_minutes, rsql = time_taken_sql_minutes   ) |>   tidyr::pivot_longer(     cols = c(dplyr, rsql),     names_to = \"M√©thode\",     values_to = \"duration\"   ) |>   ggplot(aes(x = query_period_months, y = duration, fill = M√©thode)) +   geom_col(position = \"dodge\") +   scale_x_continuous(breaks = x_breaks) +   labs(     x = \"P√©riode sur laquelle\\n porte l'extraction (mois)\",     y = \"Temps pris par l'extraction\\n sur le portail (minutes)\",     fill = \"M√©thode\"   ) +   theme_minimal() +   theme(     text = element_text(size = label_size),     axis.title = element_text(size = label_size),     legend.title = element_text(size = label_size),     legend.text = element_text(size = label_size)   )"},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"contenu-des-extractions-nombre-de-lignes","dir":"Articles","previous_headings":"R√©sultats > benchmark dplyr/RSQL","what":"Contenu des extractions (nombre de lignes)","title":"Benchmarking dplyr vs RSQL","text":"","code":"# plot time results library(ggplot2)  label_size <- 20 timing_results |>   dplyr::rename(dplyr = n_rows_dplyr, rsql = n_rows_sql) |>   tidyr::pivot_longer(     cols = c(dplyr, rsql),     names_to = \"M√©thode\",     values_to = \"n_rows\"   ) |>   ggplot(aes(x = query_period_months, y = n_rows / 1e6, fill = M√©thode)) +   geom_col(position = \"dodge\") +   scale_x_continuous(breaks = x_breaks) +   labs(     x = \"P√©riode sur laquelle\\n porte l'extraction (mois)\",     y = \"Nombres de lignes \\ndans l'extraction (millions)\",     fill = \"M√©thode\"   ) +   theme_minimal() +   theme(     text = element_text(size = label_size),     axis.title = element_text(size = label_size),     legend.title = element_text(size = label_size),     legend.text = element_text(size = label_size)   )"},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"vitesse-dextraction-en-nombre-de-lignes-extraites-par-minute","dir":"Articles","previous_headings":"R√©sultats > benchmark dplyr/RSQL","what":"Vitesse d‚Äôextraction (en nombre de lignes extraites par minute)","title":"Benchmarking dplyr vs RSQL","text":"","code":"# plot time results library(ggplot2)  label_size <- 20 timing_results |>   dplyr::rename(dplyr = speed_dplyr_nrows_sec, rsql = speed_sql_nrows_sec) |>   tidyr::pivot_longer(     cols = c(dplyr, rsql),     names_to = \"M√©thode\",     values_to = \"speed_nrows_sec\"   ) |>   ggplot(aes(x = query_period_months, y = speed_nrows_sec / 1000, fill = M√©thode)) +   geom_col(position = \"dodge\") +   scale_x_continuous(breaks = x_breaks) +   labs(     x = \"P√©riode sur laquelle\\n porte l'extraction (mois)\",     y = \"Vitesse d'extraction\\n (en milliers de lignes par seconde)\",     fill = \"M√©thode\"   ) +   theme_minimal() +   theme(     text = element_text(size = label_size),     axis.title = element_text(size = label_size),     legend.title = element_text(size = label_size),     legend.text = element_text(size = label_size)   )"},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"conclusion","dir":"Articles","previous_headings":"R√©sultats > benchmark dplyr/RSQL","what":"Conclusion","title":"Benchmarking dplyr vs RSQL","text":"Il ne semble pas y avoir de diff√©rence significative entre les deux m√©thodes d‚Äôextraction.","code":""},{"path":"/articles/benchmark_dplyr_vs_rsql.html","id":"r√©sultats-du-benchmark-en-nombres-de-lignes-x-colonnes","dir":"Articles","previous_headings":"R√©sultats","what":"R√©sultats du benchmark en nombres de lignes x colonnes","title":"Benchmarking dplyr vs RSQL","text":"Ce second benchmark √©tudie la diff√©rence pouvant √™tre observ√©e pour une requ√™te donn√©e (effectu√©e en dplyr) en fonction du nombre de colonnes extraites pour la requ√™te √©tudi√©e.  Attention: Le temps suppl√©mentaire pris par l‚Äôextraction de colonnes suppl√©mentaires peut avoir deux causes : des nombres de lignes plus √©lev√©s du fait d‚Äôun distinct sur plus de colonnes. des colonnes suppl√©mentaires qui prennent plus de temps √† extraire.","code":"path2pkg_data <- system.file(\"extdata\", package = \"sndsTools\") # path2pkg_data <- \"inst/extdata\"  label_fill <- \"Nombres\\nde colonnes\\n extraites\" timing_results_cols <- read.csv(   file.path(     path2pkg_data, \"benchmark_dplyr_speed_per_cols_rows.csv\"   ) ) |>   dplyr::mutate(     time_taken_dplyr_minutes = time_taken_dplyr / 60,     n_rows_cols = n_rows_dplyr * n_cols_dplyr,     period_months = as.numeric(       as.Date(end_date) - as.Date(start_date)     ) %/% 30,     !!sym(label_fill) := as.character(n_cols_dplyr)   ) timing_results_cols ##   start_date   end_date time_taken_dplyr n_rows_dplyr n_cols_dplyr ## 1 2020-01-01 2020-02-01         252.7808      4344565           11 ## 2 2020-01-01 2020-02-01         253.2735      4344990           16 ## 3 2020-01-01 2020-02-01         272.1631      4344991           21 ## 4 2020-01-01 2021-01-01         727.3382     48127239           11 ## 5 2020-01-01 2021-01-01         841.7315     48131304           16 ## 6 2020-01-01 2021-01-01         967.4122     48131314           21 ##   time_taken_dplyr_minutes n_rows_cols period_months ## 1                 4.213014    47790215             1 ## 2                 4.221225    69519840             1 ## 3                 4.536051    91244811             1 ## 4                12.122303   529399629            12 ## 5                14.028858   770100864            12 ## 6                16.123537  1010757594            12 ##   Nombres\\nde colonnes\\n extraites ## 1                               11 ## 2                               16 ## 3                               21 ## 4                               11 ## 5                               16 ## 6                               21 # plot time results library(ggplot2)  label_size <- 20 ggplot(timing_results_cols,   aes(x = as.character(period_months), y = time_taken_dplyr_minutes, fill = !!sym(label_fill)),   color = !!sym(label_fill) ) +   geom_col(position = \"dodge\") +   labs(     x = \"P√©riode d'extraction (mois)\",     y = \"Temps d'extraction\\n (minutes)\",     fill = label_fill   ) +   theme(     text = element_text(size = label_size),     axis.title = element_text(size = label_size),     legend.title = element_text(size = label_size),     legend.text = element_text(size = label_size)   ) ## Warning in fortify(data, ...): Arguments in `...` must be used. ## ‚úñ Problematic argument: ## ‚Ä¢ color = !!sym(label_fill) ## ‚Ñπ Did you misspell an argument name?"},{"path":[]},{"path":"/articles/contribuer.html","id":"r√©pondre-√†-une-question-sur-une-issue","dir":"Articles","previous_headings":"Diff√©rente mani√®re de contribuer","what":"R√©pondre √† une question sur une issue","title":"Contribuer","text":"De nombreuses questions sont pos√©es sur les issues. Vous pouvez y r√©pondre en donnant des conseils, ou en proposant une solution.","code":""},{"path":"/articles/contribuer.html","id":"cr√©er-une-nouvelle-issue","dir":"Articles","previous_headings":"Diff√©rente mani√®re de contribuer","what":"Cr√©er une nouvelle issue","title":"Contribuer","text":"Si vous avez trouv√© un bug, ou si vous avez une question sur une fonctionnalit√©, vous pouvez cr√©er une nouvelle issue. En cas de bug, il est important de donner un exemple reproductible reprex. Celui-ci contient le code n√©cessaire pour reproduire le bug, et le message d‚Äôerreur complet. Il est tr√®s important pour qu‚Äôun d√©veloppeur plus exp√©riment√© puisse comprendre le probl√®me et vous aider.","code":""},{"path":"/articles/contribuer.html","id":"contribuer-√†-la-documentation","dir":"Articles","previous_headings":"Diff√©rente mani√®re de contribuer","what":"Contribuer √† la documentation","title":"Contribuer","text":"Contribuer √† la documentation est aussi important que de contribuer au code. Vous pouvez proposer des modifications √† la documentation en cr√©ant une pull request. Les petites erreurs et modifications peuvent √™tre corrig√©e directment dans l‚Äôinterface web GitHub. NB: La documentation est principalement dans le code R, et est g√©n√©r√©e avec le paquet roxygen2. Pour la modifier il faut donc modifier les fichiers .R dans le dossier R/ du projet.","code":""},{"path":"/articles/contribuer.html","id":"contribuer-au-code","dir":"Articles","previous_headings":"Diff√©rente mani√®re de contribuer","what":"Contribuer au code","title":"Contribuer","text":"Afin de r√©soudre un bug, ou d‚Äôajouter une nouvelle fonctionnalit√©, vous pouvez cr√©er une pull request.","code":""},{"path":"/articles/contribuer.html","id":"principes-g√©n√©raux-de-contribution","dir":"Articles","previous_headings":"","what":"Principes g√©n√©raux de contribution","title":"Contribuer","text":"Eviter la duplication : Avant de soumettre une nouvelle issue, ou une nouvelle pull request, il est important de s‚Äôassurer qu‚Äôaucun autre contributeur n‚Äôd√©j√† pos√© la m√™me question ou contribuer sur le m√™me th√®me. Etre patient : Les contributeurs sont b√©n√©voles, effectuent la plupart du travail sur leur temps libre et peuvent ne pas r√©pondre imm√©diatement √† vos questions. Etre respectueux : Les contributeurs viennent de diff√©rents horizons, et ont des niveaux de comp√©tences diff√©rents. Il est important de respecter les opinions des autres, et de rester bienveillant.","code":""},{"path":"/articles/contribuer.html","id":"processus-dacceptation-des-pull-requests","dir":"Articles","previous_headings":"","what":"Processus d‚Äôacceptation des pull requests","title":"Contribuer","text":"Il est recommand√© de cr√©er une nouvelle branche git pour chaque nouvelle pull request (PR). Un code nouveau proposant une nouvelle fonctionnalit√© doit respecter les conventions de style R. Vous pouvez utiliser le paquet styler pour appliquer ces styles, mais s‚Äôil vous plait ne restyler pas du code qui n‚Äôrien √† faire avec votre PR. Nous utilisons roxygen2, avec la syntaxe Markdown pour la documentation. Nous suivons le guide de style de code R du tidyverse. La seule diff√©rence avec le guide actuel est que nous utilisons le pipe natif |> au lieu de %>%. Pour SQL, nous suivons le guide de style SQL de Mozilla. Nous utilisons testthat pour les tests. Les contributions avec des tests inclus sont accept√©s plus facilement. Une nouvelle PR doit √™tre revue par au moins un core contributeur avant d‚Äô√™tre int√©gr√©e.","code":""},{"path":"/articles/contribuer.html","id":"comment-contribuer-concr√®tement","dir":"Articles","previous_headings":"","what":"Comment contribuer concr√®tement ?","title":"Contribuer","text":"Afin de modifier le code, il est au pr√©alable n√©cessaire de forker le d√©p√¥t principal sur GitHub, puis de soumettre une ‚Äúpull request‚Äù (PR). Dans les premi√®res √©tapes, nous expliquons comment installer localement {sndsTools} et comment configurer votre d√©p√¥t git : Cr√©ez un compte sur GitHub si vous n‚Äôen avez pas d√©j√† un. Forkez le d√©p√¥t du projet : cliquez sur le bouton ‚ÄúFork‚Äù en haut de la page. Cela cr√©e une copie du code sur votre compte GitHub. Pour plus de d√©tails sur la mani√®re de forker un d√©p√¥t, consultez ce guide. Clonez votre fork du d√©p√¥t {sndsTools} depuis votre compte GitHub sur votre disque local : Ouvrez le projet dans Rstudio et installez localement le paquet avec les d√©pendances de d√©veloppement. Dans la console R, lancez : Ajoutez le d√©p√¥t upstream remote. Cela sauvegarde la r√©f√©rence du d√©p√¥t {sndsTools}, que vous pouvez utiliser pour garder votre version synchronis√©e avec les derniers changements. Vous devriez d√©sormais avoir une installation fonctionnelle de {sndsTools}, et votre d√©p√¥t git correctement configur√©. Vous pouvez maintenant commencer √† contribuer en modifiant le code et en soumettant une PR. Synchronisez votre branche main avec la branche upstream/main, plus de d√©tail sur la documentation GitHub: Cr√©ez une nouvelle branche pour votre contribution : Et commencez √† faire vos changements. Utilisez toujours une branche diff√©rente pour chaque nouvelle fonctionnalit√© ou bug fix. C‚Äôest une bonne pratique de ne jamais coder sur la branche main. Une fois que vous avez termin√© vos modifications, vous pouvez les commiter : puis les pousser sur votre fork : Suivez ces instructions pour cr√©er une pull request de votre travail. Cela enverra un mail aux mainteneurs du projet pour qu‚Äôils puissent examiner votre code. Il est possible qu‚Äô√† un moment, vous ayez besoin de r√©soudre des conflits, si d‚Äôautres contributeurs ont modifi√© le code pendant que vous travailliez sur votre branche. Vous pouvez vous r√©f√©rer √† cette documentation pour r√©soudre les conflits. Avant de demander une revue pour votre pull request, v√©rifier avec les commandes suivantes dans le terminal que le code passent certains test de qualit√© : que votre code ne casse pas de tests : make test que votre code respecte les conventions de style : make style que votre code respecte les conventions de lint : make lint (n√©cessite l‚Äôextension air formatter install√©e) que la documentation se g√©n√®re correctement : make doc-html","code":"git clone git@github.com:YourLogin/sndsTools.git cd sndsTools devtools::install(dependencies = TRUE) git remote add upstream git@github.com:SNDStoolers/sndsTools.git git checkout main git fetch upstream git merge upstream/main git checkout -b my-new-feature git add modified_files git commit -m 'Add some feature' git push origin my-new-feature"},{"path":"/articles/contribuer.html","id":"environnement-de-d√©veloppement","dir":"Articles","previous_headings":"","what":"Environnement de d√©veloppement","title":"Contribuer","text":"L‚Äôenvironnement de d√©veloppement recommand√© est Rstudio ou vscode. Un environnement de d√©veloppement conteneuris√© avec R et les paquets n√©cessaires au d√©veloppement peut √™tre mis en place avec vscode et l‚Äôextension Dev container (n√©cessite docker install√©). Le fichier de configuration de l‚Äôenvironnement de d√©veloppement est dans .devcontainer/devcontainer.json. Ce tutoriel explique comment utiliser les dev containers avec vscode.","code":""},{"path":"/articles/contribuer.html","id":"r√©f√©rences-pour-contribuer","dir":"Articles","previous_headings":"","what":"R√©f√©rences pour contribuer","title":"Contribuer","text":"La meilleur mani√®re d‚Äôapprendre comment contribuer est de se lancer ! N√©amoins, la lecture de certaines ressources peut √™tre utile : Guide de contribution de tidyverse Apprendre git","code":""},{"path":"/articles/gouvernance.html","id":"gouvernance","dir":"Articles","previous_headings":"","what":"Gouvernance","title":"Gouvernance","text":"Cet effort de d√©veloppement d‚Äôun paquet R pour les donn√©es du SNDS est un projet communautaire bas√© sur le consensus et l‚Äôinvestissement personnel de ses membres. Tout utilisateur ayant un int√©r√™t dans le projet peut rejoindre la communaut√©, contribuer au projet et √† ses orientations futures. Ce document pr√©cise comment la participation lieu, comment trouver / gagner sa place dans le projet, et quels sont les diff√©rents r√¥les et responsabilit√©s. Actuellement, le paquet essaye de fonctionner avec deux types de contributeurs :","code":""},{"path":"/articles/gouvernance.html","id":"les-contributeurs","dir":"Articles","previous_headings":"Gouvernance","what":"Les contributeurs","title":"Gouvernance","text":"Les contributeurs classiques faisant des issues, des reviews et des propositions de nouvelles fonctionnalit√©s (pull requests). Chaque nouvelle fonctionnalit√© avant d‚Äô√™tre int√©gr√© doit √™tre revue par un core contributeur","code":""},{"path":"/articles/gouvernance.html","id":"les-core-contributeurs","dir":"Articles","previous_headings":"Gouvernance","what":"Les core contributeurs","title":"Gouvernance","text":"Les core contributors sont particuli√®rement investis dans le projet. Ils ont des acc√®s larges sur le d√©p√¥t. Ce sont eux seulement qui valident l‚Äôint√©gration de nouvelles fonctionnalit√©s (pull requests) et peuvent fermer les issues.","code":""},{"path":"/articles/gouvernance.html","id":"devenir-un-contributeur","dir":"Articles","previous_headings":"Gouvernance","what":"Devenir un contributeur","title":"Gouvernance","text":"Tout utilisateur peut √™tre contributeur en faisant une nouvelle issue, une pull request, ou en effectuant une revue sur une pull request existante. Le guide de contribution d√©taille les diff√©rentes mani√®res de contribuer.","code":""},{"path":"/articles/gouvernance.html","id":"devenir-un-core-contributeur","dir":"Articles","previous_headings":"Gouvernance","what":"Devenir un core contributeur","title":"Gouvernance","text":"Apr√®s une ou deux pull requests ou reviews de la part d‚Äôun nouveau contributeur, sur demande de ce dernier, les core contributeurs d√©cident coll√©gialement de l‚Äôint√©grer au projet. Le nombre de core contributeur n‚Äôest pas limit√©. Le projet est en phase tr√®s pr√©coce, et accueille √† bras ouverts de nouveaux core contributeurs ü§ó.","code":""},{"path":"/articles/sndsTools.html","id":"a-quoi-sert-ce-paquet-r-de-traitement-de-donn√©es","dir":"Articles","previous_headings":"","what":"A quoi sert ce paquet R de traitement de donn√©es ?","title":"Prise en main","text":"Ce paquet R de traitement de donn√©es pour objectif de faciliter l‚Äôacc√®s aux donn√©es du Syst√®me National des Donn√©es de Sant√© (SNDS) pour les utilisateurs de R. Il permet de simplifier les extractions de donn√©es et de mettre √† disposition des fonctions impl√©mentants les bonnes pratiques pour utiliser ces donn√©es.","code":""},{"path":[]},{"path":[]},{"path":"/articles/sndsTools.html","id":"sur-le-portail-cnam","dir":"Articles","previous_headings":"Prise en main rapide > Installation","what":"Sur le portail CNAM","title":"Prise en main","text":"Pour une utilisation sur le portail CNAM, il est n√©cessaire de copier/coller le code source du paquet sur le portail CNAM. Pour cela, il faut suivre les √©tapes suivantes : En local (sur votre ordinateur) : Copier le fichier contenant toutes les fonctions: sndsTools_all.R Sur le portail CNAM, coller le contenu fichier sndsTools_all.R dans un nouveau fichier nomm√© sndsTools_all.R dans votre dossier d‚Äô√©tude. Sur le portail CNAM, au d√©but de votre fichier d‚Äô√©tude mon_etude.R, charger toutes les fonctions du paquet: {r eval = FALSE} source(\"sndsTools_all.R\").","code":""},{"path":"/articles/sndsTools.html","id":"en-local-pour-le-d√©veloppement-du-paquet","dir":"Articles","previous_headings":"Prise en main rapide > Installation","what":"En local (pour le d√©veloppement du paquet)","title":"Prise en main","text":"Ouvrir le paquet avec Rstudio, puis lancer : Puis pour charger le paquet :","code":"devtools::install(dependencies = TRUE) library(sndsTools)"},{"path":"/articles/tutoriel_avc.html","id":"contexte-de-l√©tude","dir":"Articles","previous_headings":"","what":"Contexte de l‚Äô√©tude","title":"Exemple d'√©tude possible avec sndsTools","text":"Dans le cadre de cette √©tude, nous souhaitons analyser les parcours de soins des patients hospitalis√©s pour un AVC au cours de l‚Äôann√©e 2024. Nous utiliserons les fonctions disponibles dans sndsTools pour extraire et analyser les donn√©es pertinentes. Cette √©tude est un exemple p√©dagogique de l‚Äôutilisation du package sndsTools. Elle ne constitue en aucun cas une √©tude r√©elle valide scientifiquement concernant les patients hospitalis√©s pour un AVC. Les objectifs de cette √©tude sont : Identifier les patients avec une hospitalisation pour AVC en 2024 (codes CIM-10 : I61, I62, I63, I64) via la fonction extract_hospital_stays() R√©cup√©rer leurs identifiants complets via retrieve_all_psa_from_psa() Extraire leurs consultations m√©dicales en ville via extract_consultations_erprsf() Extraire leurs Affections de Longue Dur√©e (ALD) via extract_long_term_disease() Extraire leurs prescriptions m√©dicamenteuses en ville via extract_drug_dispenses() Pr√©senter quelques analyses descriptives sur ces donn√©es","code":""},{"path":"/articles/tutoriel_avc.html","id":"pr√©requis","dir":"Articles","previous_headings":"Contexte de l‚Äô√©tude","what":"Pr√©requis","title":"Exemple d'√©tude possible avec sndsTools","text":"Avant de commencer, assurez-vous d‚Äôavoir : Une connexion √† la base de donn√©es Oracle du SNDS sur le portail de la CNAM Le code du package sndsTools copi√© sur le portail Cette vignette peut √™tre ex√©cut√©e hors du portail CNAM. Dans ce cas, des donn√©es fictives sont g√©n√©r√©es pour illustrer les √©tapes de l‚Äô√©tude.","code":"# Charger les packages n√©cessaires if (dir.exists(\"~/sasdata1\")) {     # sur le portail CNAM     source(\"../sndsTools_all.R\")     # √âtablir la connexion √† la base de donn√©es     conn <- connect_oracle() } else {     # hors portail CNAM (ex. pour construire cette vignette)     library(sndsTools)     # Charge des donn√©es fictives     conn <- create_mock_database(       n_patients = 100,       year = 2024,       start_date = as.Date(\"2024-01-01\"),       end_date = as.Date(\"2024-12-31\")     ) } #> [1] \"Le code ne s'ex√©cute pas sur le portail CNAM.\\n    Initialisation d'une connexion duckdb en m√©moire.\" #> Base de donn√©es factice cr√©√©e avec 100 patients #> P√©riode : 2024-01-01 √† 2024-12-31 #> Tables fictives MCO, ER_PRS_F, ER_PHA_F et ER_ETE_F pour l'ann√©e 2024 # packages utiles pour l'analyse library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(lubridate) #>  #> Attaching package: 'lubridate' #> The following objects are masked from 'package:base': #>  #>     date, intersect, setdiff, union library(knitr)"},{"path":"/articles/tutoriel_avc.html","id":"√©tape-1-extraction-des-hospitalisations-pour-avc","dir":"Articles","previous_headings":"Contexte de l‚Äô√©tude","what":"√âtape 1 : Extraction des hospitalisations pour AVC","title":"Exemple d'√©tude possible avec sndsTools","text":"Nous commen√ßons par extraire les s√©jours hospitaliers avec un diagnostic principal d‚ÄôAVC en utilisant la fonction extract_hospital_stays(). Les codes CIM-10 pour les AVC sont I61 (h√©morragie intrac√©r√©brale), I62 (autres h√©morragies intracr√¢niennes non traumatiques), I63 (infarctus c√©r√©bral) et I64 (accident vasculaire c√©r√©bral non pr√©cis√©).","code":"# D√©finir la p√©riode d'√©tude - ann√©e 2024 start_date <- as.Date(\"2024-01-01\") end_date <- as.Date(\"2024-12-31\")  # Codes CIM-10 pour les AVC codes_avc <- c(\"I61\", \"I62\", \"I63\", \"I64\")  # Extraire les s√©jours avec diagnostics d'AVC extract_hospital_stays(   start_date = start_date,   end_date = end_date,   dp_cim10_codes_filter = codes_avc,   or_dr_with_same_codes_filter = TRUE,  # Inclure les diagnostics reli√©s   or_da_with_same_codes_filter = FALSE,  # Exclure diagnostics associ√©s similaires   and_da_with_other_codes_filter = FALSE,  # Exclure diagnostics associ√©s diff√©rents   da_cim10_codes_filter = NULL,  # Pas de filtre sur diagnostics associ√©s   patients_ids_filter = NULL,  # Extraire tous les patients   output_table_name = \"TMP_SEJOURS_AVC\",  # Stocker en table Oracle   conn = conn ) #> Results saved to table TMP_SEJOURS_AVC in Oracle. #> NULL  # R√©cup√©rer un aper√ßu des donn√©es sejours_avc_head <- dplyr::tbl(conn, \"TMP_SEJOURS_AVC\") |>   head(5) |>   dplyr::collect()  kable(sejours_avc_head) # Analyser la r√©partition par type d'AVC avc_par_type <- dplyr::tbl(conn, \"TMP_SEJOURS_AVC\") |>   dplyr::count(DGN_PAL, sort = TRUE) |>   dplyr::mutate(pourcentage = round(n / sum(n) * 100, 1)) |>   dplyr::collect() kable(avc_par_type)"},{"path":"/articles/tutoriel_avc.html","id":"√©tape-2-identification-des-patients-uniques","dir":"Articles","previous_headings":"Contexte de l‚Äô√©tude","what":"√âtape 2 : Identification des patients uniques","title":"Exemple d'√©tude possible avec sndsTools","text":"√Ä partir des s√©jours, nous identifions les patients uniques en r√©cup√©rant leurs identifiants uniques BEN_NIR_ANO dans le r√©f√©rentiel des b√©n√©ficiaires en utilisant retrieve_all_psa_from_psa().","code":"# Cr√©er une table temporaire des pseudo-NIR des patients avec AVC patients_psa_avc <- dplyr::tbl(conn, \"TMP_SEJOURS_AVC\") |>   dplyr::select(BEN_NIR_PSA = NIR_ANO_17) |>   dplyr::distinct() |>   dplyr::collect()  # Sauvegarder temporairement dans Oracle DBI::dbWriteTable(conn, \"TMP_PATIENTS_AVC_PSA\", patients_psa_avc, overwrite = TRUE)  # R√©cup√©rer tous les identifiants patients associ√©s patients_identifiants_avc <- retrieve_all_psa_from_psa(   ben_table_name = \"TMP_PATIENTS_AVC_PSA\",   conn = conn,   output_table_name = NULL,  # Retourner data.frame   check_arc_table = FALSE # Pas de recherche dans la table d'identifiant archiv√©e, )  # Filtrer les patients avec des crit√®res de qualit√© patients_avc_qualite <- patients_identifiants_avc |>   filter(     !psa_w_multiple_idt_or_nir,  # √âviter les PSA multiples     cdi_nir_00,                   # NIR non fictifs     nir_ano_defined,              # NIR anonyme d√©fini     !birth_date_variation,        # Pas de variation date naissance     !sex_variation               # Pas de variation sexe   ) # Pr√©parer les identifiants pour les extractions ult√©rieures patients_ids_filter <- patients_avc_qualite |>   select(BEN_IDT_ANO, BEN_NIR_PSA, BEN_RNG_GEM)  paste(\"Nombre de patients uniques avec AVC :\", nrow(patients_avc_qualite)) #> [1] \"Nombre de patients uniques avec AVC : 7\""},{"path":"/articles/tutoriel_avc.html","id":"√©tape-3-extraction-des-consultations-m√©dicales","dir":"Articles","previous_headings":"Contexte de l‚Äô√©tude","what":"√âtape 3 : Extraction des consultations m√©dicales","title":"Exemple d'√©tude possible avec sndsTools","text":"Nous extrayons toutes les consultations m√©dicales en ville de ces patients en utilisant extract_consultations_erprsf().","code":"# Extraire toutes les consultations des patients avec AVC extract_consultations_erprsf(   start_date = start_date,   end_date = end_date,   pse_spe_filter = NULL,  # Toutes les sp√©cialit√©s m√©dicales   prestation_filter = NULL,  # Toutes les prestations   analyse_couts = FALSE,  # Filtrer les majorations   dis_dtd_lag_months = 6,  # D√©calage standard 6 mois   patients_ids_filter = patients_ids_filter,   output_table_name = \"TMP_CONSULTATIONS_AVC\",  # Stocker en table Oracle   conn = conn ) #> Extracting consultations from all specialties codes... #> Results saved to table TMP_CONSULTATIONS_AVC in Oracle. #> NULL  # R√©cup√©rer un aper√ßu des consultations consultations_avc_head <- dplyr::tbl(conn, \"TMP_CONSULTATIONS_AVC\") |>   head(5) |>   dplyr::collect()  # Analyser la r√©partition par sp√©cialit√© m√©dicale consultations_par_specialite <- dplyr::tbl(conn, \"TMP_CONSULTATIONS_AVC\") |>   dplyr::count(PSE_SPE_COD, sort = TRUE) |>   dplyr::mutate(pourcentage = round(n / sum(n) * 100, 1)) |>   dplyr::collect() kable(head(consultations_par_specialite, 5)) # Analyser le nombre de consultations par patient consultations_par_patient <- dplyr::tbl(conn, \"TMP_CONSULTATIONS_AVC\") |>   dplyr::group_by(BEN_IDT_ANO) |>   dplyr::summarise(     nb_consultations = n(),     premiere_consultation = min(EXE_SOI_DTD, na.rm = TRUE),     derniere_consultation = max(EXE_SOI_DTD, na.rm = TRUE),     .groups = \"drop\"   ) |>   dplyr::collect()"},{"path":"/articles/tutoriel_avc.html","id":"√©tape-4-extraction-des-affections-de-longue-dur√©e-ald","dir":"Articles","previous_headings":"Contexte de l‚Äô√©tude","what":"√âtape 4 : Extraction des Affections de Longue Dur√©e (ALD)","title":"Exemple d'√©tude possible avec sndsTools","text":"Nous extrayons les ALD des patients avec AVC en utilisant extract_long_term_disease().","code":"# Extraire les ALD des patients avec AVC patients_ids_for_ald <- patients_ids_filter |>   select(BEN_IDT_ANO, BEN_NIR_PSA)  extract_long_term_disease(   start_date = start_date,   end_date = end_date,   icd_cod_starts_with = NULL,  # Extraire toutes les ALD   ald_numbers = NULL,  # Pas de filtre sur num√©ros ALD   excl_etm_nat = c(\"11\", \"12\", \"13\"),  # Exclure accidents travail/maladies pro   patients_ids = patients_ids_for_ald,   output_table_name = \"TMP_ALD_AVC\",  # Stocker en table Oracle   overwrite = FALSE,  # Ne pas √©craser table existante   conn = conn ) #> Extracting LTD status for all ICD 10 codes... #> Results saved to table TMP_ALD_AVC in Oracle. #> NULL  # R√©cup√©rer un aper√ßu des ALD ald_avc_head <- dplyr::tbl(conn, \"TMP_ALD_AVC\") |>   head(5) |>   dplyr::collect()  kable(ald_avc_head) # Analyser la r√©partition par type d'ALD ald_resume <- dplyr::tbl(conn, \"TMP_ALD_AVC\") |>   dplyr::count(MED_MTF_COD, sort = TRUE) |>   dplyr::mutate(pourcentage = round(n / sum(n) * 100, 1)) |>   dplyr::collect() kable(head(ald_resume, 5)) # Analyser le pourcentage de patients AVC avec une ALD patients_avec_ald <- dplyr::tbl(conn, \"TMP_ALD_AVC\") |>   dplyr::select(BEN_IDT_ANO) |>   dplyr::distinct() |>   dplyr::collect() |>   nrow()  pourcentage_ald <- round(patients_avec_ald / nrow(patients_avc_qualite) * 100, 1) print(paste(\"Pourcentage de patients AVC avec une ALD :\", pourcentage_ald, \"%\")) #> [1] \"Pourcentage de patients AVC avec une ALD : 71.4 %\""},{"path":"/articles/tutoriel_avc.html","id":"√©tape-5-extraction-des-prescriptions-m√©dicamenteuses","dir":"Articles","previous_headings":"Contexte de l‚Äô√©tude","what":"√âtape 5 : Extraction des prescriptions m√©dicamenteuses","title":"Exemple d'√©tude possible avec sndsTools","text":"Nous extrayons les d√©livrances de m√©dicaments des patients avec AVC en utilisant extract_drug_dispenses().","code":"# Extraire les d√©livrances de m√©dicaments des patients avec AVC patients_ids_for_drugs <- patients_ids_filter |>   select(BEN_IDT_ANO, BEN_NIR_PSA)  # Codes ATC pour les m√©dicaments courants post-AVC # N : syst√®me nerveux # C : syst√®me cardiovasculaire atc_codes_avc <- c(\"N\", \"C\")  extract_drug_dispenses(   start_date = start_date,   end_date = end_date,   atc_cod_starts_with_filter = atc_codes_avc,  # M√©dicaments SNC et CV   cip13_cod_filter = NULL,  # Pas de filtre sp√©cifique CIP13   patients_ids_filter = patients_ids_for_drugs,   dis_dtd_lag_months = 6,  # D√©calage standard 6 mois   sup_columns = NULL,  # Pas de colonnes suppl√©mentaires   output_table_name = \"TMP_DRUG_DISPENSES_AVC\",  # Stocker en table Oracle   show_sql_query = FALSE,  # Ne pas afficher requ√™te SQL   conn = conn ) #> Extracting drug dispenses with ATC codes starting with N or C #> Extracting drug dispenses for all CIP13 codes #> -flux: DATE '2024-01-01' to DATE '2024-02-01' #> -flux: DATE '2024-02-01' to DATE '2024-03-01' #> -flux: DATE '2024-03-01' to DATE '2024-04-01' #> -flux: DATE '2024-04-01' to DATE '2024-05-01' #> -flux: DATE '2024-05-01' to DATE '2024-06-01' #> -flux: DATE '2024-06-01' to DATE '2024-07-01' #> -flux: DATE '2024-07-01' to DATE '2024-08-01' #> -flux: DATE '2024-08-01' to DATE '2024-09-01' #> -flux: DATE '2024-09-01' to DATE '2024-10-01' #> -flux: DATE '2024-10-01' to DATE '2024-11-01' #> -flux: DATE '2024-11-01' to DATE '2024-12-01' #> -flux: DATE '2024-12-01' to DATE '2025-01-01' #> -flux: DATE '2025-01-01' to DATE '2025-02-01' #> -flux: DATE '2025-02-01' to DATE '2025-03-01' #> -flux: DATE '2025-03-01' to DATE '2025-04-01' #> -flux: DATE '2025-04-01' to DATE '2025-05-01' #> -flux: DATE '2025-05-01' to DATE '2025-06-01' #> -flux: DATE '2025-06-01' to DATE '2025-07-01' #> Results saved to table TMP_DRUG_DISPENSES_AVC in Oracle. #> NULL  # R√©cup√©rer un aper√ßu des d√©livrances drugs_avc_head <- dplyr::tbl(conn, \"TMP_DRUG_DISPENSES_AVC\") |>   head(5) |>   dplyr::collect() kable(drugs_avc_head) # Analyser la r√©partition par code ATC drugs_par_atc <- dplyr::tbl(conn, \"TMP_DRUG_DISPENSES_AVC\") |>   dplyr::count(PHA_ATC_CLA, sort = TRUE) |>   dplyr::mutate(pourcentage = round(n / sum(n) * 100, 1)) |>   dplyr::collect() kable(head(drugs_par_atc, 5))"},{"path":"/articles/tutoriel_avc.html","id":"√©tape-6-nettoyage-et-fermeture-de-la-session","dir":"Articles","previous_headings":"Contexte de l‚Äô√©tude","what":"√âtape 6 : Nettoyage et fermeture de la session","title":"Exemple d'√©tude possible avec sndsTools","text":"","code":"# Supprimer les tables temporaires tables_to_remove <- c(\"TMP_PATIENTS_AVC_PSA\", \"TMP_SEJOURS_AVC\",                       \"TMP_CONSULTATIONS_AVC\", \"TMP_ALD_AVC\", \"TMP_DRUG_DISPENSES_AVC\") for (table_name in tables_to_remove) {   if (DBI::dbExistsTable(conn, table_name)) {     DBI::dbRemoveTable(conn, table_name)   } }  # Fermer la connexion DBI::dbDisconnect(conn)"},{"path":"/articles/tutoriel_avc.html","id":"conclusion","dir":"Articles","previous_headings":"Contexte de l‚Äô√©tude","what":"Conclusion","title":"Exemple d'√©tude possible avec sndsTools","text":"Ce tutoriel pr√©sent√© quelques fonctions concernant des √©tapes d‚Äôextraction usuelles √† partir du SNDS en utilisant le package sndsTools. La liste compl√®te des fonctions existantes est disponible dans la documentation du package.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Antoine Belloir. Author, maintainer. Matthieu Doutreligne. Author. Thomas Soeiro. Author. Marc Dibling. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Belloir , Doutreligne M, Soeiro T, Dibling M (2026). sndsTools: Extraction de recours aux soins sur le SNDS en R. R package version 0.0.0.1, https://sndstoolers.github.io/sndsTools/index.html/.","code":"@Manual{,   title = {sndsTools: Extraction de recours aux soins sur le SNDS en R},   author = {Antoine Belloir and Matthieu Doutreligne and Thomas Soeiro and Marc Dibling},   year = {2026},   note = {R package version 0.0.0.1},   url = {https://sndstoolers.github.io/sndsTools/index.html/}, }"},{"path":[]},{"path":"/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"Extraction de recours aux soins sur le SNDS en R","text":"Ce package R permet d‚Äôextraire des donn√©es de recours aux soins du SNDS (Syst√®me National des Donn√©es de Sant√©) pour une population donn√©e.","code":""},{"path":"/index.html","id":"fonctionnalit√©s","dir":"","previous_headings":"","what":"Fonctionnalit√©s","title":"Extraction de recours aux soins sur le SNDS en R","text":"Ce package R simplifie les √©tapes d‚Äôextraction de donn√©es du SNDS sur des donn√©es utilis√©es dans la majorit√© des √©tudes sur le SNDS. Les principales fonctionnalit√©s couvertes sont les suivantes : Effectuer l‚Äôextraction des tables individuelles pour les donn√©es suivantes : Consultations dans le DCIR, M√©dicaments dans le DCIR, Affections de longue dur√©e (ALD), Hospitalisations dans le MCO, Consultations dans le MCO. Int√®gre les requ√™tes mois par mois sur la date de flux pour les donn√©es DCIR conform√©ment aux recommandations de la CNAM. Int√®gre les filtres qualit√©s usuels pour exclure les lignes ind√©sirables (ex. PRS_DPN_QLP != 71 pour exclure les remont√©es pour information dans le DCIR).","code":""},{"path":"/index.html","id":"historique","dir":"","previous_headings":"","what":"Historique","title":"Extraction de recours aux soins sur le SNDS en R","text":"Ce projet √©t√© initi√© suite √† la rencontre de plusieurs utilisateurs du SNDS lors du congr√®s Emois en mars 2024. Il est actuellement en phase de d√©veloppement actif. C‚Äôest un projet communautaire, √©volutif par nature, qui vise √† rassembler les diff√©rents utilisateurs du SNDS.","code":""},{"path":[]},{"path":"/index.html","id":"donn√©es","dir":"","previous_headings":"Contexte technique","what":"Donn√©es","title":"Extraction de recours aux soins sur le SNDS en R","text":"Les donn√©es sont issues du SNDS et sont h√©berg√©es sur le portail de l‚Äôassurance maladie (CNAM). Pour mener utiliser ce package, il est n√©cessaire d‚Äôavoir un acc√®s aux donn√©es individuelles b√©n√©ficiaires exhaustives de consommation de soins.","code":""},{"path":"/index.html","id":"sch√©ma-de-flux-de-donn√©es","dir":"","previous_headings":"Contexte technique","what":"Sch√©ma de flux de donn√©es","title":"Extraction de recours aux soins sur le SNDS en R","text":"TODO (figure √† mettre dans man/figures)","code":""},{"path":"/index.html","id":"technologies","dir":"","previous_headings":"Contexte technique","what":"Technologies","title":"Extraction de recours aux soins sur le SNDS en R","text":"Langage de programmation : R Packages utilis√©s : dplyr, dbplyr, DBI, glue, lubridate, progress","code":""},{"path":"/index.html","id":"liens-utiles","dir":"","previous_headings":"","what":"Liens utiles","title":"Extraction de recours aux soins sur le SNDS en R","text":"lien vers cette page de la documentation : https://sndstoolers.github.io/sndsTools/index.html D√©p√¥t du code source : https://github.com/SNDStoolers/sndsTools Description des extractions et des tables de donn√©es cr√©√©es : TODO Flux de donn√©es Prise en main rapide : Prise en main R√©f√©rence des fonctions utilis√©es Guide de contribution Principes de gouvernance","code":""},{"path":"/reference/build_da_conditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Construit les conditions pour extraire les diagnostics associ√©s. ‚Äî build_da_conditions","title":"Construit les conditions pour extraire les diagnostics associ√©s. ‚Äî build_da_conditions","text":"Cette fonction permet de construire les conditions pour extraire les diagnostics associ√©s.","code":""},{"path":"/reference/build_da_conditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construit les conditions pour extraire les diagnostics associ√©s. ‚Äî build_da_conditions","text":"","code":"build_da_conditions(cim10_codes = NULL)"},{"path":"/reference/build_da_conditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construit les conditions pour extraire les diagnostics associ√©s. ‚Äî build_da_conditions","text":"cim10_codes character vector Les codes CIM10 cibles des diagnostics √† extraire.","code":""},{"path":"/reference/build_da_conditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construit les conditions pour extraire les diagnostics associ√©s. ‚Äî build_da_conditions","text":"character Les conditions pour extraire les diagnostics associ√©s.","code":""},{"path":"/reference/build_da_conditions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construit les conditions pour extraire les diagnostics associ√©s. ‚Äî build_da_conditions","text":"","code":"if (FALSE) { # \\dontrun{ build_da_conditions(c(\"A00\", \"B00\")) } # }"},{"path":"/reference/build_dp_dr_conditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Construit les conditions pour extraire les diagnostics principaux et reli√©s. ‚Äî build_dp_dr_conditions","title":"Construit les conditions pour extraire les diagnostics principaux et reli√©s. ‚Äî build_dp_dr_conditions","text":"Cette fonction permet de construire les conditions pour extraire les diagnostics principaux et reli√©s.","code":""},{"path":"/reference/build_dp_dr_conditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construit les conditions pour extraire les diagnostics principaux et reli√©s. ‚Äî build_dp_dr_conditions","text":"","code":"build_dp_dr_conditions(cim10_codes = NULL, include_dr = FALSE)"},{"path":"/reference/build_dp_dr_conditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construit les conditions pour extraire les diagnostics principaux et reli√©s. ‚Äî build_dp_dr_conditions","text":"cim10_codes character vector Les codes CIM10 cibles des diagnostics √† extraire. include_dr logical Indique si les diagnostics reli√©s doivent √™tre ajout√©s dans les conditions. Si TRUE, la recherche dans les diagnostics principaux des codes CIM10 cibles est ajout√©e dans les conditions. Si FALSE, les codes CIM10 cibles sont recherch√©s seulement pour les diagnostics principaux.","code":""},{"path":"/reference/build_dp_dr_conditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construit les conditions pour extraire les diagnostics principaux et reli√©s. ‚Äî build_dp_dr_conditions","text":"character Les conditions pour extraire les diagnostics principaux et reli√©s.","code":""},{"path":"/reference/build_dp_dr_conditions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construit les conditions pour extraire les diagnostics principaux et reli√©s. ‚Äî build_dp_dr_conditions","text":"","code":"if (FALSE) { # \\dontrun{ build_dp_dr_conditions(c(\"A00\", \"B00\"), include_dr = TRUE) build_dp_dr_conditions(c(\"A00\", \"B00\"), include_dr = FALSE) } # }"},{"path":"/reference/connect_duckdb.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialisation de la connexion √† la base de donn√©es duckdb. ‚Äî connect_duckdb","title":"Initialisation de la connexion √† la base de donn√©es duckdb. ‚Äî connect_duckdb","text":"Utilisation pour le testing uniquement. Si le code s'ex√©cute en dehors du portail, il faut initier une connexion duckdb pour effectuer les tests.","code":""},{"path":"/reference/connect_duckdb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialisation de la connexion √† la base de donn√©es duckdb. ‚Äî connect_duckdb","text":"","code":"connect_duckdb()"},{"path":"/reference/connect_duckdb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialisation de la connexion √† la base de donn√©es duckdb. ‚Äî connect_duckdb","text":"dbConnection Connexion √† la base de donn√©es duckdb","code":""},{"path":"/reference/connect_oracle.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialisation de la connexion √† la base de donn√©es. ‚Äî connect_oracle","title":"Initialisation de la connexion √† la base de donn√©es. ‚Äî connect_oracle","text":"Initialisation de la connexion √† la base de donn√©es.","code":""},{"path":"/reference/connect_oracle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialisation de la connexion √† la base de donn√©es. ‚Äî connect_oracle","text":"","code":"connect_oracle()"},{"path":"/reference/connect_oracle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialisation de la connexion √† la base de donn√©es. ‚Äî connect_oracle","text":"dbConnection Connexion √† la base de donn√©es oracle","code":""},{"path":"/reference/create_mock_database.html","id":null,"dir":"Reference","previous_headings":"","what":"Configurer une base de donn√©es DuckDB avec toutes les tables factices ‚Äî create_mock_database","title":"Configurer une base de donn√©es DuckDB avec toutes les tables factices ‚Äî create_mock_database","text":"Configurer une base de donn√©es DuckDB avec toutes les tables factices","code":""},{"path":"/reference/create_mock_database.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configurer une base de donn√©es DuckDB avec toutes les tables factices ‚Äî create_mock_database","text":"","code":"create_mock_database(   n_patients = 100,   year = 2020,   start_date = as.Date(\"2020-01-01\"),   end_date = as.Date(\"2020-12-31\") )"},{"path":"/reference/create_mock_database.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configurer une base de donn√©es DuckDB avec toutes les tables factices ‚Äî create_mock_database","text":"n_patients Nombre de patients √† g√©n√©rer year Ann√©e pour les tables MCO start_date Date de d√©but end_date Date de fin","code":""},{"path":"/reference/create_mock_database.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configurer une base de donn√©es DuckDB avec toutes les tables factices ‚Äî create_mock_database","text":"Connexion DuckDB avec toutes les tables charg√©es","code":""},{"path":"/reference/create_mock_er_ete_f.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©er des donn√©es factices pour ER_ETE_F (Actes externes) ‚Äî create_mock_er_ete_f","title":"Cr√©er des donn√©es factices pour ER_ETE_F (Actes externes) ‚Äî create_mock_er_ete_f","text":"Cr√©er des donn√©es factices pour ER_ETE_F (Actes externes)","code":""},{"path":"/reference/create_mock_er_ete_f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cr√©er des donn√©es factices pour ER_ETE_F (Actes externes) ‚Äî create_mock_er_ete_f","text":"","code":"create_mock_er_ete_f(er_prs_f)"},{"path":"/reference/create_mock_er_ete_f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©er des donn√©es factices pour ER_ETE_F (Actes externes) ‚Äî create_mock_er_ete_f","text":"er_prs_f data.frame des prescriptions","code":""},{"path":"/reference/create_mock_er_ete_f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cr√©er des donn√©es factices pour ER_ETE_F (Actes externes) ‚Äî create_mock_er_ete_f","text":"data.frame avec donn√©es d'actes externes","code":""},{"path":"/reference/create_mock_er_pha_f.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©er des donn√©es factices pour les m√©dicaments d√©livr√©s (ER_PHA_F) ‚Äî create_mock_er_pha_f","title":"Cr√©er des donn√©es factices pour les m√©dicaments d√©livr√©s (ER_PHA_F) ‚Äî create_mock_er_pha_f","text":"Cr√©er des donn√©es factices pour les m√©dicaments d√©livr√©s (ER_PHA_F)","code":""},{"path":"/reference/create_mock_er_pha_f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cr√©er des donn√©es factices pour les m√©dicaments d√©livr√©s (ER_PHA_F) ‚Äî create_mock_er_pha_f","text":"","code":"create_mock_er_pha_f(er_prs_f)"},{"path":"/reference/create_mock_er_pha_f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©er des donn√©es factices pour les m√©dicaments d√©livr√©s (ER_PHA_F) ‚Äî create_mock_er_pha_f","text":"er_prs_f data.frame des prescriptions","code":""},{"path":"/reference/create_mock_er_pha_f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cr√©er des donn√©es factices pour les m√©dicaments d√©livr√©s (ER_PHA_F) ‚Äî create_mock_er_pha_f","text":"data.frame avec les donn√©es des m√©dicaments","code":""},{"path":"/reference/create_mock_er_prs_f.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©er des donn√©es factices pour les d√©livrances de m√©dicaments (ER_PRS_F) ‚Äî create_mock_er_prs_f","title":"Cr√©er des donn√©es factices pour les d√©livrances de m√©dicaments (ER_PRS_F) ‚Äî create_mock_er_prs_f","text":"Cr√©er des donn√©es factices pour les d√©livrances de m√©dicaments (ER_PRS_F)","code":""},{"path":"/reference/create_mock_er_prs_f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cr√©er des donn√©es factices pour les d√©livrances de m√©dicaments (ER_PRS_F) ‚Äî create_mock_er_prs_f","text":"","code":"create_mock_er_prs_f(   patients_ids = create_mock_patients_ids(),   start_date = as.Date(\"2020-01-01\"),   end_date = as.Date(\"2020-12-31\"),   n_dispenses = 5 )"},{"path":"/reference/create_mock_er_prs_f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©er des donn√©es factices pour les d√©livrances de m√©dicaments (ER_PRS_F) ‚Äî create_mock_er_prs_f","text":"patients_ids data.frame avec BEN_IDT_ANO et BEN_NIR_PSA start_date Date de d√©but end_date Date de fin n_dispenses Nombre de d√©livrances par patient (moyenne)","code":""},{"path":"/reference/create_mock_er_prs_f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cr√©er des donn√©es factices pour les d√©livrances de m√©dicaments (ER_PRS_F) ‚Äî create_mock_er_prs_f","text":"data.frame avec les donn√©es de d√©livrances","code":""},{"path":"/reference/create_mock_ir_ben_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©er des donn√©es factices pour IR_BEN_R (r√©f√©rentiel b√©n√©ficiaires) ‚Äî create_mock_ir_ben_r","title":"Cr√©er des donn√©es factices pour IR_BEN_R (r√©f√©rentiel b√©n√©ficiaires) ‚Äî create_mock_ir_ben_r","text":"Cr√©er des donn√©es factices pour IR_BEN_R (r√©f√©rentiel b√©n√©ficiaires)","code":""},{"path":"/reference/create_mock_ir_ben_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cr√©er des donn√©es factices pour IR_BEN_R (r√©f√©rentiel b√©n√©ficiaires) ‚Äî create_mock_ir_ben_r","text":"","code":"create_mock_ir_ben_r(patients_ids = create_mock_patients_ids())"},{"path":"/reference/create_mock_ir_ben_r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©er des donn√©es factices pour IR_BEN_R (r√©f√©rentiel b√©n√©ficiaires) ‚Äî create_mock_ir_ben_r","text":"patients_ids data.frame avec BEN_IDT_ANO et BEN_NIR_PSA","code":""},{"path":"/reference/create_mock_ir_ben_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cr√©er des donn√©es factices pour IR_BEN_R (r√©f√©rentiel b√©n√©ficiaires) ‚Äî create_mock_ir_ben_r","text":"data.frame avec toutes les colonnes du r√©f√©rentiel b√©n√©ficiaires","code":""},{"path":"/reference/create_mock_ir_imb_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©er des donn√©es factices pour les ALD (IR_IMB_R) ‚Äî create_mock_ir_imb_r","title":"Cr√©er des donn√©es factices pour les ALD (IR_IMB_R) ‚Äî create_mock_ir_imb_r","text":"Cr√©er des donn√©es factices pour les ALD (IR_IMB_R)","code":""},{"path":"/reference/create_mock_ir_imb_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cr√©er des donn√©es factices pour les ALD (IR_IMB_R) ‚Äî create_mock_ir_imb_r","text":"","code":"create_mock_ir_imb_r(   patients_ids = create_mock_patients_ids(),   start_date = as.Date(\"2020-01-01\"),   end_date = as.Date(\"2020-12-31\") )"},{"path":"/reference/create_mock_ir_imb_r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©er des donn√©es factices pour les ALD (IR_IMB_R) ‚Äî create_mock_ir_imb_r","text":"patients_ids data.frame avec BEN_IDT_ANO et BEN_NIR_PSA start_date Date de d√©but end_date Date de fin","code":""},{"path":"/reference/create_mock_ir_imb_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cr√©er des donn√©es factices pour les ALD (IR_IMB_R) ‚Äî create_mock_ir_imb_r","text":"data.frame avec les donn√©es d'ALD","code":""},{"path":"/reference/create_mock_ir_pha_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©er des donn√©es factices pour le r√©f√©rentiel m√©dicaments (IR_PHA_R) ‚Äî create_mock_ir_pha_r","title":"Cr√©er des donn√©es factices pour le r√©f√©rentiel m√©dicaments (IR_PHA_R) ‚Äî create_mock_ir_pha_r","text":"Cr√©er des donn√©es factices pour le r√©f√©rentiel m√©dicaments (IR_PHA_R)","code":""},{"path":"/reference/create_mock_ir_pha_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cr√©er des donn√©es factices pour le r√©f√©rentiel m√©dicaments (IR_PHA_R) ‚Äî create_mock_ir_pha_r","text":"","code":"create_mock_ir_pha_r()"},{"path":"/reference/create_mock_ir_pha_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cr√©er des donn√©es factices pour le r√©f√©rentiel m√©dicaments (IR_PHA_R) ‚Äî create_mock_ir_pha_r","text":"data.frame avec les codes CIP13 et ATC","code":""},{"path":"/reference/create_mock_mco_tables.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©er des donn√©es factices pour les s√©jours hospitaliers MCO (tables B, C, D, UM) ‚Äî create_mock_mco_tables","title":"Cr√©er des donn√©es factices pour les s√©jours hospitaliers MCO (tables B, C, D, UM) ‚Äî create_mock_mco_tables","text":"Cr√©er des donn√©es factices pour les s√©jours hospitaliers MCO (tables B, C, D, UM)","code":""},{"path":"/reference/create_mock_mco_tables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cr√©er des donn√©es factices pour les s√©jours hospitaliers MCO (tables B, C, D, UM) ‚Äî create_mock_mco_tables","text":"","code":"create_mock_mco_tables(   patients_ids = create_mock_patients_ids(),   year = 2020,   start_date = as.Date(\"2020-01-01\"),   end_date = as.Date(\"2020-12-31\") )"},{"path":"/reference/create_mock_mco_tables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©er des donn√©es factices pour les s√©jours hospitaliers MCO (tables B, C, D, UM) ‚Äî create_mock_mco_tables","text":"patients_ids data.frame avec BEN_IDT_ANO et BEN_NIR_PSA year Ann√©e des s√©jours start_date Date de d√©but end_date Date de fin","code":""},{"path":"/reference/create_mock_mco_tables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cr√©er des donn√©es factices pour les s√©jours hospitaliers MCO (tables B, C, D, UM) ‚Äî create_mock_mco_tables","text":"list avec les 4 tables MCO (B, C, D, UM)","code":""},{"path":"/reference/create_mock_patients_ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Fonctions pour cr√©er des donn√©es factices pour le tutoriel sndsTools ‚Äî create_mock_patients_ids","title":"Fonctions pour cr√©er des donn√©es factices pour le tutoriel sndsTools ‚Äî create_mock_patients_ids","text":"Ce fichier contient des fonctions pour g√©n√©rer des donn√©es d'exemple bas√©es sur les structures utilis√©es dans les tests du package sndsTools.","code":""},{"path":"/reference/create_mock_patients_ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fonctions pour cr√©er des donn√©es factices pour le tutoriel sndsTools ‚Äî create_mock_patients_ids","text":"","code":"create_mock_patients_ids(n_patients = 100)"},{"path":"/reference/create_mock_patients_ids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fonctions pour cr√©er des donn√©es factices pour le tutoriel sndsTools ‚Äî create_mock_patients_ids","text":"n_patients Nombre de patients √† g√©n√©rer","code":""},{"path":"/reference/create_mock_patients_ids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fonctions pour cr√©er des donn√©es factices pour le tutoriel sndsTools ‚Äî create_mock_patients_ids","text":"data.frame avec BEN_IDT_ANO et BEN_NIR_PSA","code":""},{"path":"/reference/create_mock_patients_ids.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fonctions pour cr√©er des donn√©es factices pour le tutoriel sndsTools ‚Äî create_mock_patients_ids","text":"Matthieu Doutreligne Cr√©er des donn√©es factices pour les patients","code":""},{"path":"/reference/create_table_from_query.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©ation d'une table √† partir d'une requ√™te SQL. ‚Äî create_table_from_query","title":"Cr√©ation d'une table √† partir d'une requ√™te SQL. ‚Äî create_table_from_query","text":"Cr√©ation d'une table √† partir d'une requ√™te SQL.","code":""},{"path":"/reference/create_table_from_query.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cr√©ation d'une table √† partir d'une requ√™te SQL. ‚Äî create_table_from_query","text":"","code":"create_table_from_query(   conn = NULL,   output_table_name = NULL,   query = NULL,   overwrite = FALSE )"},{"path":"/reference/create_table_from_query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©ation d'une table √† partir d'une requ√™te SQL. ‚Äî create_table_from_query","text":"conn Connexion √† la base de donn√©es output_table_name Nom de la table de sortie query Requ√™te SQL overwrite Logical. Indique si la table output_table_name doit √™tre √©cras√©e dans le cas o√π elle existe d√©j√†.","code":""},{"path":"/reference/create_table_from_query.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cr√©ation d'une table √† partir d'une requ√™te SQL. ‚Äî create_table_from_query","text":"La fonction cr√©e une table sous Oracle √† partir d'une requ√™te SQL. Si la table output_table_name existe d√©j√†, elle est √©cras√©e si le param√®tre overwrite est TRUE.","code":""},{"path":"/reference/extract_consultations_erprsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Extraction des consultations dans le DCIR. ‚Äî extract_consultations_erprsf","title":"Extraction des consultations dans le DCIR. ‚Äî extract_consultations_erprsf","text":"Cette fonction permet d'extraire les consultations dans le DCIR. Les consultations dont les dates EXE_SOI_DTD sont comprises entre start_date et end_date (incluses) sont extraites.","code":""},{"path":"/reference/extract_consultations_erprsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extraction des consultations dans le DCIR. ‚Äî extract_consultations_erprsf","text":"","code":"extract_consultations_erprsf(   start_date,   end_date,   pse_spe_filter = NULL,   prestation_filter = NULL,   analyse_couts = FALSE,   dis_dtd_lag_months = 6,   patients_ids_filter = NULL,   output_table_name = NULL,   conn = NULL )"},{"path":"/reference/extract_consultations_erprsf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extraction des consultations dans le DCIR. ‚Äî extract_consultations_erprsf","text":"start_date Date. La date de d√©but de la p√©riode des consultations √† extraire. end_date Date. La date de fin de la p√©riode des consultations √† extraire. pse_spe_filter Character vector (Optionnel). Les codes sp√©cialit√©s des m√©decins (r√©f√©rentiel IR_SPE_V) effectuant les consultations √† extraire. Si pse_spe_filter n'est pas fourni, les consultations de tous les sp√©cialit√©s sont extraites. D√©faut √† NULL. prestation_filter Character vector (Optionnel). Les codes des prestations √† extraire en norme B5 (colonne PRS_NAT_REF, r√©f√©rentiel IR_NAT_V). Si prestation_filter n'est pas fourni, les consultations de tous les prestations sont extraites. Les codes des prestations sont disponibles sur la page \"Cibler selon les natures de prestations\" de la documentation SNDS. D√©faut √† NULL. analyse_couts Logical (Optionnel). Si TRUE, les filtres de qualit√© li√©s aux co√ªts, √©cartant les actes en majorations sont ignor√©s. Utile pour des analyses portant sur les co√ªts. D√©faut √† FALSE. dis_dtd_lag_months Integer (Optionnel). Le nombre maximum de mois de d√©calage de FLX_DIS_DTD par rapport √† EXE_SOI DTD pris en compte pour r√©cup√©rer les consultations. D√©faut √† 6 mois. patients_ids_filter data frame (Optionnel). Un data frame contenant les paires d'identifiants des patients pour lesquels les consultations doivent √™tre extraites. Les colonnes de ce data frame doivent √™tre BEN_IDT_ANO, BEN_NIR_PSA et BEN_RNG_GEM. Les BEN_NIR_PSA doivent √™tre tous les BEN_NIR_PSA associ√©s aux BEN_IDT_ANO fournis. D√©faut √† NULL. output_table_name Character (Optionnel). Si fourni, les r√©sultats seront sauvegard√©s dans une table portant ce nom dans la base de donn√©es au lieu d'√™tre retourn√©s sous forme de data frame. Si cette table existe d√©j√†, le programme s'arr√™te avec un message d'erreur. D√©faut √† NULL. conn DBI connection (Optionnel). Une connexion √† la base de donn√©es Oracle. Par d√©faut, une connexion est √©tablie avec oracle.","code":""},{"path":"/reference/extract_consultations_erprsf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extraction des consultations dans le DCIR. ‚Äî extract_consultations_erprsf","text":"Si output_table_name est NULL, retourne un data frame contenant les consultations. Si output_table_name est fourni, sauvegarde les r√©sultats dans la table sp√©cifi√©e dans Oracle et retourne NULL de mani√®re invisible. Dans les deux cas les colonnes de la table de sortie sont : BEN_NIR_PSA : Colonne pr√©sente uniquement si les identifiants patients (patients_ids_filter) ne sont pas fournis. Identifiant SNDS, aussi appel√© pseudo-NIR. BEN_IDT_ANO : Colonne pr√©sente uniquement si les identifiants patients (patients_ids_filter) sont fournis. Num√©ro d‚Äôinscription au r√©pertoire (NIR) anonymis√©. EXE_SOI_DTD : Date de la consultation.","code":""},{"path":"/reference/extract_consultations_erprsf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extraction des consultations dans le DCIR. ‚Äî extract_consultations_erprsf","text":"Le d√©calage de remont√©e des donn√©es est pris en compte en r√©cup√©rant √©galement les consultations dont les dates FLX_DIS_DTD sont comprises dans les dis_dtd_lag_months mois suivant end_date. Si patients_ids_filter est fourni, seules les consultations pour les patients dont les identifiants sont dans patients_ids_filter sont extraites. Dans le cas contraire, les consultations de tous les patients sont extraites. Pour √™tre √† flux constant sur l'ensemble des ann√©es, il faut utiliser dis_dtd_lag_months = 27 Cela rallonge le temps d'extraction alors que l'impact sur l'extraction est minime car la Cnam estime que 99 % des soins sont remont√©s √† 6 mois c'est-√†-dire pour dis_dtd_lag_months = 6. Un guide sur l'activit√© des m√©decins lib√©raux est disponibles sur la page Activit√© des m√©decins lib√©raux.","code":""},{"path":"/reference/extract_consultations_erprsf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extraction des consultations dans le DCIR. ‚Äî extract_consultations_erprsf","text":"","code":"if (FALSE) { # \\dontrun{ dispenses <- extract_consultations_erprsf(   start_date = as.Date(\"2010-01-01\"),   end_date = as.Date(\"2010-01-03\"),   pse_spe_filter = c(\"0\", \"00\", \"36\") ) } # }"},{"path":"/reference/extract_drug_dispenses.html","id":null,"dir":"Reference","previous_headings":"","what":"Extraction des d√©livrances de m√©dicaments. ‚Äî extract_drug_dispenses","title":"Extraction des d√©livrances de m√©dicaments. ‚Äî extract_drug_dispenses","text":"Cette fonction permet d'extraire les d√©livrances de m√©dicaments par code ATC ou par code CIP13. Les d√©livrances dont les dates EXE_SOI_DTD sont comprises entre start_date et end_date (incluses) sont extraites.","code":""},{"path":"/reference/extract_drug_dispenses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extraction des d√©livrances de m√©dicaments. ‚Äî extract_drug_dispenses","text":"","code":"extract_drug_dispenses(   start_date,   end_date,   atc_cod_starts_with_filter = NULL,   cip13_cod_filter = NULL,   patients_ids_filter = NULL,   dis_dtd_lag_months = 6,   sup_columns = NULL,   output_table_name = NULL,   conn = NULL,   show_sql_query = TRUE )"},{"path":"/reference/extract_drug_dispenses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extraction des d√©livrances de m√©dicaments. ‚Äî extract_drug_dispenses","text":"start_date Date. La date de d√©but de la p√©riode des d√©livrances des m√©dicaments √† extraire. end_date Date. La date de fin de la p√©riode des d√©livrances des m√©dicaments √† extraire. atc_cod_starts_with_filter Character vector (Optionnel). Les codes ATC par lesquels les d√©livrances de m√©dicaments √† extraire doivent commencer. D√©faut √† NULL. cip13_cod_filter Character vector (Optionnel). Les codes CIP des d√©livrances de m√©dicaments √† extraire en compl√©ment des codes ATC. D√©faut √† NULL. patients_ids_filter data.frame (Optionnel). Un data.frame contenant les paires d'identifiants des patients pour lesquels les d√©livrances de m√©dicaments doivent √™tre extraites. Les colonnes de ce data.frame doivent √™tre \"BEN_IDT_ANO\" et \"BEN_NIR_PSA\". Les \"BEN_NIR_PSA\" doivent √™tre tous les \"BEN_NIR_PSA\" associ√©s aux \"BEN_IDT_ANO\" fournis. D√©faut √† NULL. dis_dtd_lag_months Integer (Optionnel). Le nombre maximum de mois de d√©calage de FLX_DIS_DTD par rapport √† EXE_SOI DTD pris en compte pour r√©cup√©rer les d√©livrances de m√©dicaments. D√©faut √† 6 mois. sup_columns Character vector (Optionnel). Les colonnes suppl√©mentaires √† ajouter √† la table de sortie. D√©faut √† NULL, donc aucune colonne ajout√©e. output_table_name Character (Optionnel). Si fourni, les r√©sultats seront sauvegard√©s dans une table portant ce nom dans la base de donn√©es au lieu d'√™tre retourn√©s sous forme de data frame. Si la table existe d√©j√† dans la base oracle, alors le programme s'arr√™te en retournant une erreur. D√©fault √† NULL. conn DBI connection (Optionnel). Une connexion √† la base de donn√©es Oracle. Si non fournie, une connexion est √©tablie par d√©faut. D√©faut √† NULL.","code":""},{"path":"/reference/extract_drug_dispenses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extraction des d√©livrances de m√©dicaments. ‚Äî extract_drug_dispenses","text":"Si output_table_name est NULL, retourne un data.frame contenant les d√©livrances de m√©dicaments. Si output_table_name est fourni, sauvegarde les r√©sultats dans la table sp√©cifi√©e dans Oracle et retourne NULL de mani√®re invisible. Dans les deux cas les colonnes de la table de sortie sont : BEN_NIR_PSA : Colonne pr√©sente uniquement si les identifiants patients (patients_ids_filter) ne sont pas fournis. Identifiant SNDS, aussi appel√© pseudo-NIR. BEN_IDT_ANO : Colonne pr√©sente uniquement si les identifiants patients (patients_ids_filter) sont fournis. Num√©ro d‚Äôinscription au r√©pertoire (NIR) anonymis√©. EXE_SOI_DTD : Date de la d√©livrance PHA_ACT_QSN : Quantit√© d√©livr√©e PHA_ATC_CLA : Code ATC du m√©dicament d√©livr√© PHA_PRS_C13 : Code CIP du m√©dicament d√©livr√© (nom dans la table ER_PHA_F : PHA_PRS_C13, nom dans la table IR_PHA_R : PHA_CIP_C13) PSP_SPE_COD : Code de sp√©cialit√© du professionnel de soin prescripteur (voir nomenclature IR_SPE_V) Les colonnes suppl√©mentaires sp√©cifi√©es dans sup_columns si fournies.","code":""},{"path":"/reference/extract_drug_dispenses.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extraction des d√©livrances de m√©dicaments. ‚Äî extract_drug_dispenses","text":"Le d√©calage de remont√©e des donn√©es est pris en compte en r√©cup√©rant √©galement les d√©livrances dont les dates FLX_DIS_DTD sont comprises dans les dis_dtd_lag_months mois suivant end_date. Si atc_cod_starts_with ou cip13_codes sont fournies, seules les d√©livrances de m√©dicaments dont le code ATC commence par l'un des √©l√©ments de atc_cod_starts_with OU dont le code CIP13 est dans cip13_codes sont extraites. Dans le cas ou aucun des filtres n'est renseign√©, les d√©livrances pour tous les codes ATC et CIP13 sont extraites. Si l'un des filtres est NULL, mais pas l'autre, seul les d√©livrances pour le filtre non NULL sont extraites. Si patients_ids_filter est fourni, seules les d√©livrances de m√©dicaments pour les patients dont les identifiants sont dans patients_ids_filter sont extraites. Dans le cas contraire, les d√©livrances de tous les patients sont extraites. Pour √™tre √† flux constant sur l'ensemble des ann√©es, il faut utiliser dis_dtd_lag_months = 27 Cela rallonge le temps d'extraction alors que l'impact sur l'extraction est minime car la Cnam estime que 99 % des soins sont remont√©s √† 6 mois, c'est-√†-dire pour dis_dtd_lag_months = 6.","code":""},{"path":"/reference/extract_drug_dispenses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extraction des d√©livrances de m√©dicaments. ‚Äî extract_drug_dispenses","text":"","code":"if (FALSE) { # \\dontrun{ start_date <- as.Date(\"2010-01-01\") end_date <- as.Date(\"2010-01-03\") atc_cod_starts_with <- c(\"N04A\")  dispenses <- extract_drug_dispenses(   start_date = start_date,   end_date = end_date,   atc_cod_starts_with = atc_cod_starts_with ) } # }"},{"path":"/reference/extract_hospital_consultations.html","id":null,"dir":"Reference","previous_headings":"","what":"Extraction des consultations externes √† l'h√¥pital (MCO). ‚Äî extract_hospital_consultations","title":"Extraction des consultations externes √† l'h√¥pital (MCO). ‚Äî extract_hospital_consultations","text":"Cette fonction permet d'extraire les consultations √† l'h√¥pital en MCO. Les consultations dont les dates EXE_SOI_DTD sont comprises entre start_date et end_date sont extraites.","code":""},{"path":"/reference/extract_hospital_consultations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extraction des consultations externes √† l'h√¥pital (MCO). ‚Äî extract_hospital_consultations","text":"","code":"extract_hospital_consultations(   start_date,   end_date,   spe_codes_filter = NULL,   prestation_codes_filter = NULL,   patient_ids_filter = NULL,   output_table_name = NULL,   conn = NULL )"},{"path":"/reference/extract_hospital_consultations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extraction des consultations externes √† l'h√¥pital (MCO). ‚Äî extract_hospital_consultations","text":"start_date Date La date de d√©but de la p√©riode sur laquelle extraire les consultations. end_date Date La date de fin de la p√©riode sur laquelle extraire les consultations. spe_codes_filter character vector Optionnel. Les codes sp√©cialit√©s des m√©decins effectuant les consultations √† extraire. Si spe_codes n'est pas fourni, les consultations de tous les sp√©cialit√©s sont extraites. prestation_codes_filter character vector Optionnel. Les codes des prestations √† extraire. Si prestation_codes n'est pas fourni, les consultations de tous les prestations sont extraites. Les codes des prestations sont disponibles sur la page actes et consultations externes de la documentation SNDS. patient_ids_filter data.frame Optionnel. Un data.frame contenant les paires d'identifiants des patients pour lesquels les consultations doivent √™tre extraites. Les colonnes de ce data.frame doivent √™tre BEN_IDT_ANO et BEN_NIR_PSA (en majuscules). Les BEN_NIR_PSA doivent √™tre tous les BEN_NIR_PSA associ√©s aux BEN_IDT_ANO fournis. Si patients_ids n'est pas fourni, les consultations de tous les patients sont extraites. output_table_name character Optionnel. Le nom de la table de sortie dans la base de donn√©es. Si output_table_name n'est pas fourni, une table de sortie interm√©diaire est cr√©√©e en R. Si output_table_name est fourni mais que cette table existe d√©j√† dans oracle, le programme s'arr√™te avec un message d'erreur. conn dbConnection La connexion √† la base de donn√©es. Si conn n'est pas fourni, une connexion √† la base de donn√©es est initialis√©e. Par d√©faut, une connexion est √©tablie avec oracle.","code":""},{"path":"/reference/extract_hospital_consultations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extraction des consultations externes √† l'h√¥pital (MCO). ‚Äî extract_hospital_consultations","text":"Un data.frame contenant les consultations. Les colonnes sont les suivantes : BEN_IDT_ANO : Identifiant b√©n√©ficiaire anonymis√© (seulement si patient_ids non nul) NIR_ANO_17 : NIR anonymis√© EXE_SOI_DTD : Date de la d√©livrance ACT_COD : Code de l'acte EXE_SPE : Code de sp√©cialit√© du professionnel de soin prescripteur","code":""},{"path":"/reference/extract_hospital_consultations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extraction des consultations externes √† l'h√¥pital (MCO). ‚Äî extract_hospital_consultations","text":"Si spe_codes est renseign√©, seules les consultations des sp√©cialit√©s correspondantes sont extraites. Si prestation_codes est renseign√©, seules les consultations des prestations correspondantes sont extraites. Si patients_ids est fourni, seules les d√©livrances de m√©dicaments pour les patients dont les identifiants sont dans patients_ids sont extraites.","code":""},{"path":"/reference/extract_hospital_consultations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extraction des consultations externes √† l'h√¥pital (MCO). ‚Äî extract_hospital_consultations","text":"","code":"if (FALSE) { # \\dontrun{ extract_hospital_consultations(   start_date = as.Date(\"2019-01-01\"),   end_date = as.Date(\"2019-12-31\"),   spe_codes = c(\"01\", \"02\") ) } # }"},{"path":"/reference/extract_hospital_stays.html","id":null,"dir":"Reference","previous_headings":"","what":"Extraction des diagnostics des s√©jours hospitaliers (MCO). ‚Äî extract_hospital_stays","title":"Extraction des diagnostics des s√©jours hospitaliers (MCO). ‚Äî extract_hospital_stays","text":"Cette fonction permet d'extraire les diagnostics des s√©jours hospitaliers en MCO. Les diagnostics dont les dates EXE_SOI_DTD sont comprises entre start_date et end_date sont extraits.","code":""},{"path":"/reference/extract_hospital_stays.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extraction des diagnostics des s√©jours hospitaliers (MCO). ‚Äî extract_hospital_stays","text":"","code":"extract_hospital_stays(   start_date,   end_date,   dp_cim10_codes_filter = NULL,   or_dr_with_same_codes_filter = FALSE,   or_da_with_same_codes_filter = FALSE,   and_da_with_other_codes_filter = FALSE,   da_cim10_codes_filter = NULL,   patients_ids_filter = NULL,   output_table_name = NULL,   conn = NULL )"},{"path":"/reference/extract_hospital_stays.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extraction des diagnostics des s√©jours hospitaliers (MCO). ‚Äî extract_hospital_stays","text":"start_date Date La date de d√©but de la p√©riode sur laquelle extraire les s√©jours. end_date Date La date de fin de la p√©riode sur laquelle extraire les s√©jours. dp_cim10_codes_filter character vector (Optionnel). Les codes CIM10 des diagnostics principaux √† extraire. La requ√™te est effectu√©e par pr√©fixe : Par exemple, si E12 est renseign√©, tous les codes commen√ßant par E12 sont extraits. D√©faut √† NULL. and_da_with_other_codes_filter logical (Optionnel). Indique si les s√©jours avec des codes DA diff√©rents doivent √™tre extraits. La requ√™te est effectu√©e par pr√©fixe : Par exemple, si E12 est renseign√©, tous les codes commen√ßant par E12 sont extraits. D√©faut √† NULL. da_cim10_codes_filter character vector (Optionnel). Les codes CIM10 des diagnostics associ√©s √† extraire. La requ√™te est effectu√©e par pr√©fixe : Par exemple, si E12 est renseign√©, tous les codes commen√ßant par E12 sont extraits. D√©faut √† NULL. patients_ids_filter data.frame (Optionnel). Un data.frame contenant les paires d'identifiants des patients pour lesquels les consultations doivent √™tre extraites. Les colonnes de ce data.frame doivent √™tre BEN_IDT_ANO et BEN_NIR_PSA (en majuscules). Les \"BEN_NIR_PSA\" doivent √™tre tous les \"BEN_NIR_PSA\" associ√©s aux \"BEN_IDT_ANO\" fournis. Si patients_ids n'est pas fourni, les consultations de tous les patients sont extraites. D√©faut √† NULL. output_table_name character Le nom de la table de sortie dans la base de donn√©es. Si output_table_name n'est pas fourni, une table de sortie interm√©diaire est cr√©√©e. D√©faut √† NULL. conn dbConnection La connexion √† la base de donn√©es. Si conn n'est pas fourni, une connexion √† la base de donn√©es est initialis√©e. D√©faut √† NULL. or_dr_with_same_codes logical (Optionnel).Indique si les s√©jours avec les m√™mes codes DR doivent √™tre extraits. La requ√™te est effectu√©e par pr√©fixe : Par exemple, si E12 est renseign√©, tous les codes commen√ßant par E12 sont extraits. D√©faut √† NULL. or_da_with_same_codes logical (Optionnel). Indique si les s√©jours avec les m√™mes codes DA doivent √™tre extraits. La requ√™te est effectu√©e par pr√©fixe : Par exemple, si E12 est renseign√©, tous les codes commen√ßant par E12 sont extraits. D√©faut √† NULL.","code":""},{"path":"/reference/extract_hospital_stays.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extraction des diagnostics des s√©jours hospitaliers (MCO). ‚Äî extract_hospital_stays","text":"Un data.frame contenant les s√©jours hospitaliers. Attention: Les lignes des tables MCO B et C peuvent √™tre dupliqu√©es. Les colonnes sont les suivantes : BEN_IDT_ANO : Identifiant b√©n√©ficiaire anonymis√© (seulement si patient_ids non nul) NIR_ANO_17 : NIR anonymis√© EXE_SOI_DTD : Date de d√©but du s√©jour hospitalier EXE_SOI_DTF : Date de fin du s√©jour hospitalier ETA_NUM : Num√©ro FINESS e-PMSI RSA_NUM : N¬∞ d'index du RSA SEJ_NUM : N¬∞ de s√©jour SEJ_NBJ : Nombre de jours de s√©jour NBR_DGN : Nombre de diagnostics associ√©s significatifs NBR_RUM : Nombre de RUM (unit√© m√©dicales) NBR_ACT : Nombre d'actes ENT_MOD : Mode d'entr√©e ENT_PRV : Provenance SOR_MOD : Mode de sortie SOR_DES : Destination DGN_PAL : Diagnostic principal DGN_REL : Diagnostic reli√© GRG_GHM : Groupe homog√®ne de malades BDI_DEP : D√©partement de r√©sidence BDI_COD : Code postal de r√©sidence COD_SEX : Sexe AGE_ANN : Age en ann√©es AGE_JOU : Age en jours DGN_PAL_UM : Diagnostic principal des unit√© m√©dicale DGN_REL_UM : Diagnostic reli√© des unit√© m√©dicale ASS_DGN : Diagnostic associ√©","code":""},{"path":"/reference/extract_hospital_stays.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extraction des diagnostics des s√©jours hospitaliers (MCO). ‚Äî extract_hospital_stays","text":"La s√©lection des s√©jours se fait √† l'aide de filtres sur les diagnostics: Si dp_cim10_codes_filter est renseign√©, seuls les s√©jours dont les diagnostics principaux contiennent les codes CIM10 correspondants sont extraits. Si or_dr_with_same_codes_filter est renseign√©, les s√©jours avec les codes DR correspondants sont √©galement extraits. Si or_da_with_same_codes_filter est renseign√©, les s√©jours avec les codes DA correspondants sont √©galement extraits. Si and_da_with_other_codes_filter est renseign√©, les s√©jours avec les codes DA diff√©rents sont √©galement extraits. Tous les diagnostics principaux, reli√©s et associ√©s sont extraits pour les s√©jours s√©lectionn√©s. La fonction joint les tables T_MCOB, T_MCOC ensemble, puis joint successivement √† cette table \"s√©jour\" les tables T_MCOD et T_MCOUM. Finalement, les deux tables obtenues sont concat√©n√©es horizontalement. Il est donc fr√©quent d'avoir des doublons concernant les colonnes des tables B et C dans les lignes de la table r√©sultante. Une explication d√©taill√©e et un diagramme illustrant le fonctionnement retenu sont disponibles sur le github du projet Scalpel.","code":""},{"path":"/reference/extract_hospital_stays.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extraction des diagnostics des s√©jours hospitaliers (MCO). ‚Äî extract_hospital_stays","text":"","code":"if (FALSE) { # \\dontrun{ extract_hospital_stays(   start_date =     as.Date(\"2019-01-01\"), end_date = as.Date(\"2019-12-31\"), dp_cim10_codes =     c(\"A00\", \"B00\") ) } # }"},{"path":"/reference/extract_long_term_disease.html","id":null,"dir":"Reference","previous_headings":"","what":"Extraction des Affections Longue Dur√©e (ALD) ‚Äî extract_long_term_disease","title":"Extraction des Affections Longue Dur√©e (ALD) ‚Äî extract_long_term_disease","text":"Cette fonction permet d'extraire des ALD actives au moins un jour sur une p√©riode donn√©e. Les ALD dont l'intersection IMB_ALD_DTD, IMB_ALD_DTF avec la p√©riode start_date, end_date n'est pas vide sont extraites. Si des codes ICD 10 ou des num√©ros d'ALD sont fournis, seules les ALD associ√©es √† ces codes ICD 10 ou num√©ros d'ALD sont extraites. Dans le cas contraire, toutes les ALD sont extraites. Si des identifiants de patients sont fournis, seules les ALD associ√©es √† ces patients sont extraites. Dans le cas contraire, les ALD de tous les patients sont extraites.","code":""},{"path":"/reference/extract_long_term_disease.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extraction des Affections Longue Dur√©e (ALD) ‚Äî extract_long_term_disease","text":"","code":"extract_long_term_disease(   start_date = NULL,   end_date = NULL,   icd_cod_starts_with = NULL,   ald_numbers = NULL,   excl_etm_nat = c(\"11\", \"12\", \"13\"),   patients_ids = NULL,   output_table_name = NULL,   overwrite = FALSE,   conn = NULL )"},{"path":"/reference/extract_long_term_disease.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extraction des Affections Longue Dur√©e (ALD) ‚Äî extract_long_term_disease","text":"start_date Date La date de d√©but de la p√©riode sur laquelle extraire les ALD actives. end_date Date La date de fin de la p√©riode sur laquelle extraire les ALD actives. icd_cod_starts_with character vector Un vecteur de codes ICD 10. Si icd_cod_starts_with ou ald_numbers sont fournis, seules les ALD associ√©es √† ces codes ICD 10 ou num√©ros d'ALD sont extraites. Sinon, toutes les ALD actives sur la p√©riode start_date, end_date sont extraites. ald_numbers numeric vector Un vecteur de num√©ros d'ALD. Si icd_cod_starts_with ou ald_numbers sont fournis, seules les ALD associ√©es √† ces codes ICD 10 ou num√©ros d'ALD sont extraites. Sinon, toutes les ALD actives sur la p√©riode start_date, end_date sont extraites. excl_etm_nat character vector Un vecteur de codes IMB_ETM_NAT √† exclure. Par d√©faut, les ALD de nature 11, 12 et 13 sont exclues car elles correspondent √† des exon√©rations pour accidents du travail ou maladies professionnelles. Voir la fiche sur les ALD de la documentation du SNDS. et notamment le Programme #1 pour la r√©f√©rence de ce filtre. patients_ids data.frame Optionnel. Un data.frame contenant les paires d'identifiants des patients pour lesquels les d√©livrances de m√©dicaments doivent √™tre extraites. Les colonnes de ce data.frame doivent √™tre \"BEN_IDT_ANO\" et \"BEN_NIR_PSA\". Les \"BEN_NIR_PSA\" doivent √™tre tous les \"BEN_NIR_PSA\" associ√©s aux \"BEN_IDT_ANO\" fournis. output_table_name Character Optionnel. Si fourni, les r√©sultats seront sauvegard√©s dans une table portant ce nom dans la base de donn√©es au lieu d'√™tre retourn√©s sous forme de data frame. overwrite Logical. Indique si la table output_table_name doit √™tre √©cras√©e dans le cas o√π elle existe d√©j√†. conn DBI connection Une connexion √† la base de donn√©es Oracle. Si non fournie, une connexion est √©tablie par d√©faut.","code":""},{"path":"/reference/extract_long_term_disease.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extraction des Affections Longue Dur√©e (ALD) ‚Äî extract_long_term_disease","text":"Si output_table_name est NULL, retourne un data.frame contenant les les ALDs actives sur la p√©riode. Si output_table_name est fourni, sauvegarde les r√©sultats dans la table sp√©cifi√©e dans Oracle et retourne NULL de mani√®re invisible. Dans les deux cas les colonnes de la table de sortie sont : BEN_NIR_PSA : Colonne pr√©sente uniquement si les identifiants patients (patients_ids) ne sont pas fournis. Identifiant SNDS, ausi appel√© pseudo-NIR. BEN_IDT_ANO : Colonne pr√©sente uniquement si les identifiants patients (patients_ids) sont fournis. Num√©ro d‚Äôinscription au r√©pertoire (NIR) anonymis√©. IMB_ALD_NUM : Le num√©ro de l'ALD IMB_ALD_DTD : La date de d√©but de l'ALD IMB_ALD_DTF : La date de fin de l'ALD IMB_ETM_NAT : La nature de l'ALD MED_MTF_COD : Le code ICD 10 de la pathologie associ√©e √† l'ALD","code":""},{"path":"/reference/extract_long_term_disease.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extraction des Affections Longue Dur√©e (ALD) ‚Äî extract_long_term_disease","text":"","code":"if (FALSE) { # \\dontrun{ start_date <- as.Date(\"2010-01-01\") end_date <- as.Date(\"2010-01-03\") icd_cod_starts_with <- c(\"G20\")  long_term_disease <- extract_long_term_disease(   start_date = start_date,   end_date = end_date,   icd_cod_starts_with = icd_cod_starts_with ) } # }"},{"path":"/reference/gather_table_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"R√©cup√©ration des statistiques des tables ‚Äî gather_table_stats","title":"R√©cup√©ration des statistiques des tables ‚Äî gather_table_stats","text":"R√©cup√©ration des statistiques des tables","code":""},{"path":"/reference/gather_table_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R√©cup√©ration des statistiques des tables ‚Äî gather_table_stats","text":"","code":"gather_table_stats(conn, table)"},{"path":"/reference/gather_table_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R√©cup√©ration des statistiques des tables ‚Äî gather_table_stats","text":"conn Connexion √† la base de donn√©es table Chaine de caract√®re indiquant le nom d'une table","code":""},{"path":"/reference/gather_table_stats.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"R√©cup√©ration des statistiques des tables ‚Äî gather_table_stats","text":"https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_STATS.html#GUID-CA6A56B9-0540-45E9-B1D7-D78769B7714C #nolint","code":""},{"path":"/reference/get_first_non_archived_year.html","id":null,"dir":"Reference","previous_headings":"","what":"R√©cup√©ration de l'ann√©e non archiv√©e la plus ancienne de la table ER_PRS_F. ‚Äî get_first_non_archived_year","title":"R√©cup√©ration de l'ann√©e non archiv√©e la plus ancienne de la table ER_PRS_F. ‚Äî get_first_non_archived_year","text":"R√©cup√©ration de l'ann√©e non archiv√©e la plus ancienne de la table ER_PRS_F.","code":""},{"path":"/reference/get_first_non_archived_year.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R√©cup√©ration de l'ann√©e non archiv√©e la plus ancienne de la table ER_PRS_F. ‚Äî get_first_non_archived_year","text":"","code":"get_first_non_archived_year(conn)"},{"path":"/reference/get_first_non_archived_year.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R√©cup√©ration de l'ann√©e non archiv√©e la plus ancienne de la table ER_PRS_F. ‚Äî get_first_non_archived_year","text":"conn Connexion √† la base de donn√©es","code":""},{"path":"/reference/get_first_non_archived_year.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R√©cup√©ration de l'ann√©e non archiv√©e la plus ancienne de la table ER_PRS_F. ‚Äî get_first_non_archived_year","text":"Ann√©e non archiv√©e la plus ancienne","code":""},{"path":"/reference/insert_into_table_from_query.html","id":null,"dir":"Reference","previous_headings":"","what":"Insertion des r√©sultats d'une requ√™te SQL dans une table existante. ‚Äî insert_into_table_from_query","title":"Insertion des r√©sultats d'une requ√™te SQL dans une table existante. ‚Äî insert_into_table_from_query","text":"Insertion des r√©sultats d'une requ√™te SQL dans une table existante.","code":""},{"path":"/reference/insert_into_table_from_query.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insertion des r√©sultats d'une requ√™te SQL dans une table existante. ‚Äî insert_into_table_from_query","text":"","code":"insert_into_table_from_query(   conn = NULL,   output_table_name = NULL,   query = NULL )"},{"path":"/reference/insert_into_table_from_query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insertion des r√©sultats d'une requ√™te SQL dans une table existante. ‚Äî insert_into_table_from_query","text":"conn Connexion √† la base de donn√©es output_table_name Nom de la table de sortie query Requ√™te SQL","code":""},{"path":"/reference/retrieve_all_psa_from_idt.html","id":null,"dir":"Reference","previous_headings":"","what":"Gestion des identifiants patients √† l'aide de BEN_IDT_ANO ‚Äî retrieve_all_psa_from_idt","title":"Gestion des identifiants patients √† l'aide de BEN_IDT_ANO ‚Äî retrieve_all_psa_from_idt","text":"La fonction retrieve_all_psa_from_idt permet d'extraire le ref√©rentiel des b√©n√©ficiaires avec la cl√© de jointure la plus fine (l'ensemble des BEN_NIR_PSA) √† partir d'une table contenant un identifiant patient BEN_IDT_ANO. Cinq variables binaires sont ajout√©es en sortie pour aider au processus d'inclusion : psa_w_multiple_idt_or_nir : permet d'identifier les BEN_IDT_ANO ou BEN_NIR_ANO pr√©sentant des BEN_NIR_PSA associ√©s √† plusieurs BEN_IDT_ANO ou BEN_NIR_ANO. cdi_nir_00 : permet d'identifier les BEN_NIR_PSA non fictifs. nir_ano_defined : permet d'identifier les BEN_NIR_PSA pour lesquels un BEN_NIR_ANO est d√©fini. birth_date_variation : permet d'identifier les BEN_IDT_ANO pr√©sentant des inconsistances au niveau de la date de naissance. sex_variation : permet d'identifier les BEN_IDT_ANO pr√©sentant des inconsistances relatives aux codes sexe.","code":""},{"path":"/reference/retrieve_all_psa_from_idt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gestion des identifiants patients √† l'aide de BEN_IDT_ANO ‚Äî retrieve_all_psa_from_idt","text":"","code":"retrieve_all_psa_from_idt(   ben_table_name,   conn = NULL,   check_arc_table = TRUE,   output_table_name = NULL )"},{"path":"/reference/retrieve_all_psa_from_idt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gestion des identifiants patients √† l'aide de BEN_IDT_ANO ‚Äî retrieve_all_psa_from_idt","text":"ben_table_name Character Obligatoire. Nom de la table d'entr√©e comprenant au moins la variable BEN_NIR_PSA. Si la variable BEN_RNG_GEM est incluse, elle sera √©galement utilis√©e pour les jointures avec les r√©f√©rentiels. conn DBI connection Optionnel Une connexion √† la base de donn√©es Oracle. Si non fournie, une connexion est √©tablie par d√©faut. check_arc_table Logical Optionnel. Si TRUE (par d√©faut), les tables IR_BEN_R_ARC sont √©galement consult√©es pour la recherche des BEN_IDT_ANO et des crit√®res de s√©lection. output_table_name Character Optionnel. Si fourni, les r√©sultats seront sauvegard√©s dans une table portant ce nom dans Oracle. Sinon la table en sortie est retourn√©e sous la forme d'un data.frame(/tibble).","code":""},{"path":"/reference/retrieve_all_psa_from_idt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gestion des identifiants patients √† l'aide de BEN_IDT_ANO ‚Äî retrieve_all_psa_from_idt","text":"partir d'une table avec BEN_IDT_ANO, la fonction retournera l'ensemble des BEN_NIR_PSA + BEN_RNG_GEM associ√©s au BEN_IDT_ANO dans une table d√©doublonn√©e. La table en sortie est une copie de(s) r√©f√©rentiel(s) IR_BEN_R (et IR_BEN_R_ARC) relatifs aux BEN_IDT_ANO impliqu√©s et enregistr√©e sous Oracle ou retourn√©e sous la forme d'un data.frame(/tibble). Si output_table_name est NULL, retourne un data.frame(/tibble). Si output_table_name est fourni, sauvegarde les r√©sultats dans la table sp√©cifi√©e dans Oracle et retourne NULL de mani√®re invisible. Dans les deux cas les colonnes de la table de sortie sont celles des tables IR_BEN_R et IR_BEN_R_ARC auxquelles sont ajout√©es les variables binaires: psa_w_multiple_idt_or_nir (Logical): permet de v√©rifier que chaque BEN_NIR_PSA est associ√© √† un seul BEN_IDT_ANO ou BEN_NIR_ANO. Si cette relation d‚Äôunicit√© est respect√©e, alors les bases PMSI et DCIR peuvent √™tre interrog√©es directement √† partir de la variable BEN_NIR_PSA, qui suffit alors pour identifier de mani√®re unique un patient. Dans le cas contraire, seules les tables du DCIR peuvent √™tre exploit√©es pour effectuer des requ√™tes √† l‚Äô√©chelle d‚Äôun patient unique. Il est alors n√©cessaire de prendre en compte les variables BEN_IDT_ANO, BEN_RNG_GEM et BEN_ORG_AFF afin d‚Äôassurer une interpr√©tation correcte des identifiants. La variable BEN_NIR_ANO, bien qu‚Äôelle permette th√©oriquement de distinguer les individus de mani√®re anonyme, peut √™tre manquante. Quant √† BEN_RNG_GEM, d√©fini comme le rang g√©mellaire, il peut prendre diff√©rentes valeurs en cas de changement de r√©gime, identifiable via la variable BEN_ORG_AFF. Source : https://documentation-snds.health-data-hub.fr/files/Sante_publique_France/2021-10-SpF-SNDS-ce-quil-faut-savoir-v3-MPL-2.0.pdf. cdi_nir_00 (Logical): permet d'identifier les BEN_NIR_PSA non fictifs nir_ano_defined (Logical): permet d'identifier les BEN_NIR_PSA pour lesquels un BEN_NIR_ANO et un BEN_IDT_ANO sont d√©fini birth_date_variation (Logical): permet d'identifier les BEN_IDT_ANO pr√©sentant des dates de naissance diff√©rentes pour un m√™me BEN_IDT_ANO sex_variation (Logical): permet d'identifier les BEN_IDT_ANO pr√©sentant des codes sexe diff√©rents pour un m√™me BEN_IDT_ANO","code":""},{"path":"/reference/retrieve_all_psa_from_idt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gestion des identifiants patients √† l'aide de BEN_IDT_ANO ‚Äî retrieve_all_psa_from_idt","text":"La fonction retourne une copie du/des r√©f√©rentiel(s) IR_BEN_R (/IR_BEN_R_ARC) dans une table d√©doublonn√©e avec des indicateurs visant √† am√©liorer le processus d'inclusion.","code":""},{"path":"/reference/retrieve_all_psa_from_idt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gestion des identifiants patients √† l'aide de BEN_IDT_ANO ‚Äî retrieve_all_psa_from_idt","text":"","code":"if (FALSE) { # \\dontrun{ # Cr√©ation et enregistrement dans Oracle d'un tibble de 100 BEN_IDT_ANO idt_sample_1 <- dplyr::tbl(conn, \"IR_BEN_R\") |>   dplyr::select(BEN_IDT_ANO) |>   dplyr::distinct() |>   head(100) |>   dplyr::collect() dbWriteTable(conn, \"IDT_SAMP_1\", idt_sample_1, overwrite = TRUE)  # R√©cup√©ration de la table en format tibble retrieve_all_psa_from_idt(conn = conn, ben_table_name = \"IDT_SAMP_1\") # R√©cup√©ration et enregistrement de la table dans Oracle retrieve_all_psa_from_idt(   conn = conn,   ben_table_name = \"IDT_SAMP_1\",   output_table_name = \"TEST_SAVE_ORACLE\" ) # R√©cup√©ration de la table sans consid√©rer la table de r√©f√©rentiel archiv√©e retrieve_all_psa_from_idt(   conn = conn,   ben_table_name = \"IDT_SAMP_1\",   check_arc_table = FALSE ) } # }"},{"path":"/reference/retrieve_all_psa_from_psa.html","id":null,"dir":"Reference","previous_headings":"","what":"Gestion des identifiants patients √† l'aide de BEN_NIR_PSA ‚Äî retrieve_all_psa_from_psa","title":"Gestion des identifiants patients √† l'aide de BEN_NIR_PSA ‚Äî retrieve_all_psa_from_psa","text":"La fonction retrieve_all_psa_from_psa permet d'extraire le ref√©rentiel des b√©n√©ficiaires avec la cl√© de jointure la plus fine (l'ensemble des BEN_NIR_PSA) √† partir d'une table contenant un identifiant patient BEN_NIR_PSA. Cinq variables binaires sont ajout√©es en sortie pour aider au processus d'inclusion : psa_w_multiple_idt_or_nir : permet d'identifier les BEN_IDT_ANO ou BEN_NIR_ANO pr√©sentant des BEN_NIR_PSA associ√©s √† plusieurs BEN_IDT_ANO ou BEN_NIR_ANO. cdi_nir_00 : permet d'identifier les BEN_NIR_PSA non fictifs. nir_ano_defined : permet d'identifier les BEN_NIR_PSA pour lesquels un BEN_NIR_ANO est d√©fini. birth_date_variation : permet d'identifier les BEN_IDT_ANO pr√©sentant des inconsistances au niveau de la date de naissance. sex_variation : permet d'identifier les BEN_IDT_ANO pr√©sentant des inconsistances relatives aux codes sexe.","code":""},{"path":"/reference/retrieve_all_psa_from_psa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gestion des identifiants patients √† l'aide de BEN_NIR_PSA ‚Äî retrieve_all_psa_from_psa","text":"","code":"retrieve_all_psa_from_psa(   ben_table_name,   conn = NULL,   check_arc_table = TRUE,   output_table_name = NULL )"},{"path":"/reference/retrieve_all_psa_from_psa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gestion des identifiants patients √† l'aide de BEN_NIR_PSA ‚Äî retrieve_all_psa_from_psa","text":"ben_table_name Character Obligatoire. Nom de la table d'entr√©e comprenant au moins la variable BEN_IDT_ANO. Si la variable BEN_RNG_GEM est incluse, elle sera √©galement utilis√©e pour les jointures avec les r√©f√©rentiels. conn DBI connection Optionnel Une connexion √† la base de donn√©es Oracle. Si non fournie, une connexion est √©tablie par d√©faut. check_arc_table Logical Optionnel. Si TRUE (par d√©faut), les tables IR_BEN_R_ARC sont √©galement consult√©es pour la recherche des BEN_IDT_ANO et des crit√®res de s√©lection. output_table_name Character Optionnel. Si fourni, les r√©sultats seront sauvegard√©s dans une table portant ce nom dans Oracle. Sinon la table en sortie est retourn√©e sous la forme d'un data.frame(/tibble).","code":""},{"path":"/reference/retrieve_all_psa_from_psa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gestion des identifiants patients √† l'aide de BEN_NIR_PSA ‚Äî retrieve_all_psa_from_psa","text":"partir d'une table avec BEN_IDT_ANO, la fonction retournera l'ensemble des BEN_NIR_PSA + BEN_RNG_GEM associ√©s au BEN_IDT_ANO dans une table d√©doublonn√©e. La table en sortie est une copie de(s) r√©f√©rentiel(s) IR_BEN_R (et IR_BEN_R_ARC) relatifs aux BEN_IDT_ANO impliqu√©s et enregistr√©e sous Oracle ou retourn√©e sous la forme d'un data.frame(/tibble). Si output_table_name est NULL, retourne un data.frame(/tibble). Si output_table_name est fourni, sauvegarde les r√©sultats dans la table sp√©cifi√©e dans Oracle et retourne NULL de mani√®re invisible. Dans les deux cas les colonnes de la table de sortie sont celles des tables IR_BEN_R et IR_BEN_R_ARC auxquelles sont ajout√©es les variables binaires: psa_w_multiple_idt_or_nir (Logical): permet de v√©rifier que chaque BEN_NIR_PSA est associ√© √† un seul BEN_IDT_ANO ou BEN_NIR_ANO. Si cette relation d‚Äôunicit√© est respect√©e, alors les bases PMSI et DCIR peuvent √™tre interrog√©es directement √† partir de la variable BEN_NIR_PSA, qui suffit alors pour identifier de mani√®re unique un patient. Dans le cas contraire, seules les tables du DCIR peuvent √™tre exploit√©es pour effectuer des requ√™tes √† l‚Äô√©chelle d‚Äôun patient unique. Il est alors n√©cessaire de prendre en compte les variables BEN_IDT_ANO, BEN_RNG_GEM et BEN_ORG_AFF afin d‚Äôassurer une interpr√©tation correcte des identifiants. La variable BEN_NIR_ANO, bien qu‚Äôelle permette th√©oriquement de distinguer les individus de mani√®re anonyme, peut √™tre manquante. Quant √† BEN_RNG_GEM, d√©fini comme le rang g√©mellaire, il peut prendre diff√©rentes valeurs en cas de changement de r√©gime, identifiable via la variable BEN_ORG_AFF. Source : https://documentation-snds.health-data-hub.fr/files/Sante_publique_France/2021-10-SpF-SNDS-ce-quil-faut-savoir-v3-MPL-2.0.pdf. cdi_nir_00 (Logical): permet d'identifier les BEN_NIR_PSA non fictifs nir_ano_defined (Logical): permet d'identifier les BEN_NIR_PSA pour lesquels un BEN_NIR_ANO et un BEN_IDT_ANO sont d√©fini birth_date_variation (Logical): permet d'identifier les BEN_IDT_ANO pr√©sentant des dates de naissance diff√©rentes pour un m√™me BEN_IDT_ANO sex_variation (Logical): permet d'identifier les BEN_IDT_ANO pr√©sentant des codes sexe diff√©rents pour un m√™me BEN_IDT_ANO","code":""},{"path":"/reference/retrieve_all_psa_from_psa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gestion des identifiants patients √† l'aide de BEN_NIR_PSA ‚Äî retrieve_all_psa_from_psa","text":"La fonction retourne une copie du/des r√©f√©rentiel(s) √åR_BEN_R (/√åR_BEN_R_ARC) dans une table d√©doublonn√©e avec des indicateurs visant √† am√©liorer le processus d'inclusion.","code":""},{"path":"/reference/retrieve_all_psa_from_psa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gestion des identifiants patients √† l'aide de BEN_NIR_PSA ‚Äî retrieve_all_psa_from_psa","text":"","code":"if (FALSE) { # \\dontrun{ # Cr√©ation et enregistrement dans Oracle de 100 couples de (BEN_NIR_PSA+BEN_RNG_GEM) psa_sample_2 <- dplyr::tbl(conn, \"IR_BEN_R\") |>   dplyr::select(BEN_NIR_PSA, BEN_RNG_GEM) |>   head(100) |>   dplyr::collect() dbWriteTable(conn, \"PSA_SAMP_2\", psa_sample_2, overwrite = TRUE) # R√©cup√©ration de la table en format tibble retrieve_all_psa_from_psa(conn = conn, ben_table_name = \"PSA_SAMP_2\") # R√©cup√©ration et enregistrement de la table dans Oracle retrieve_all_psa_from_psa(   conn = conn,   ben_table_name = \"PSA_SAMP_2\",   output_table_name = \"TEST_SAVE_ORACLE\" ) # R√©cup√©ration de la table sans consid√©rer la table de r√©f√©rentiel archiv√©e retrieve_all_psa_from_psa(   conn = conn,   ben_table_name = \"PSA_SAMP_2\",   check_arc_table = FALSE ) } # }"},{"path":"/reference/sql_extract_drug_dispenses.html","id":null,"dir":"Reference","previous_headings":"","what":"Extraction des d√©livrances de m√©dicaments √† partir de SQL inject√© dans du R (mod√®le dbExecute de Thomas Soeiro). ‚Äî sql_extract_drug_dispenses","title":"Extraction des d√©livrances de m√©dicaments √† partir de SQL inject√© dans du R (mod√®le dbExecute de Thomas Soeiro). ‚Äî sql_extract_drug_dispenses","text":"Cette fonction permet d'extraire les d√©livrances de m√©dicaments par code ATC ou par code CIP13. Les d√©livrances dont les dates EXE_SOI_DTD sont comprises entre start_date et end_date (incluses) sont extraites.","code":""},{"path":"/reference/sql_extract_drug_dispenses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extraction des d√©livrances de m√©dicaments √† partir de SQL inject√© dans du R (mod√®le dbExecute de Thomas Soeiro). ‚Äî sql_extract_drug_dispenses","text":"","code":"sql_extract_drug_dispenses(   start_date,   end_date,   output_table_name,   atc_cod_starts_with_filter = NULL,   cip13_cod_filter = NULL,   conn = NULL )"},{"path":"/reference/sql_extract_drug_dispenses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extraction des d√©livrances de m√©dicaments √† partir de SQL inject√© dans du R (mod√®le dbExecute de Thomas Soeiro). ‚Äî sql_extract_drug_dispenses","text":"start_date Date. La date de d√©but de la p√©riode des d√©livrances des m√©dicaments √† extraire. end_date Date. La date de fin de la p√©riode des d√©livrances des m√©dicaments √† extraire. output_table_name Character (Optionnel). Si fourni, les r√©sultats seront sauvegard√©s dans une table portant ce nom dans la base de donn√©es au lieu d'√™tre retourn√©s sous forme de data frame. D√©fault √† NULL. atc_cod_starts_with_filter Character vector (Optionnel). Les codes ATC par lesquels les d√©livrances de m√©dicaments √† extraire doivent commencer. D√©faut √† NULL. cip13_cod_filter Character vector (Optionnel). Les codes CIP des d√©livrances de m√©dicaments √† extraire en compl√©ment des codes ATC. D√©faut √† NULL. conn DBI connection (Optionnel). Une connexion √† la base de donn√©es Oracle. Si non fournie, une connexion est √©tablie par d√©faut. D√©faut √† NULL.","code":""}]
